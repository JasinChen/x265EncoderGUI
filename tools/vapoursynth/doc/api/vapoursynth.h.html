<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VapourSynth.h &mdash; VapourSynth R58 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="VSHelper.h" href="vshelper.h.html" />
    <link rel="prev" title="VapourSynth C API Reference" href="../apireference.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> VapourSynth
          </a>
              <div class="version">
                R58
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gettingstarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pythonreference.html">Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../functions.html">Function Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications.html">Applications and Libraries</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../apireference.html">VapourSynth C API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../apireference.html#public-headers">Public Headers</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">VapourSynth.h</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#table-of-contents">Table of contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#macros">Macros</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enums">Enums</a></li>
<li class="toctree-l4"><a class="reference internal" href="#structs">Structs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-plugins">Writing plugins</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="vshelper.h.html">VSHelper.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="vsscript.h.html">VSScript.h</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../apireference.html#common-pitfalls">Common Pitfalls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../apireference.html#reserved-frame-properties">Reserved Frame Properties</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">VapourSynth</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../apireference.html">VapourSynth C API Reference</a> &raquo;</li>
      <li>VapourSynth.h</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/vapoursynth.h.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="vapoursynth-h">
<h1>VapourSynth.h<a class="headerlink" href="#vapoursynth-h" title="Permalink to this headline"></a></h1>
<section id="table-of-contents">
<h2>Table of contents<a class="headerlink" href="#table-of-contents" title="Permalink to this headline"></a></h2>
<p><a class="reference internal" href="#introduction">Introduction</a></p>
<dl>
<dt><a class="reference internal" href="#macros">Macros</a></dt><dd><p><a class="reference internal" href="#vs-cc">VS_CC</a></p>
<p><a class="reference internal" href="#vs-external-api">VS_EXTERNAL_API</a></p>
<p><a class="reference internal" href="#vapoursynth-api-major">VAPOURSYNTH_API_MAJOR</a></p>
<p><a class="reference internal" href="#vapoursynth-api-minor">VAPOURSYNTH_API_MINOR</a></p>
<p><a class="reference internal" href="#vapoursynth-api-version">VAPOURSYNTH_API_VERSION</a></p>
</dd>
<dt><a class="reference internal" href="#enums">Enums</a></dt><dd><p><a class="reference internal" href="#vscolorfamily">VSColorFamily</a></p>
<p><a class="reference internal" href="#vssampletype">VSSampleType</a></p>
<p><a class="reference internal" href="#vspresetformat">VSPresetFormat</a></p>
<p><a class="reference internal" href="#vsfiltermode">VSFilterMode</a></p>
<p><a class="reference internal" href="#vsnodeflags">VSNodeFlags</a></p>
<p><a class="reference internal" href="#vsproptypes">VSPropTypes</a></p>
<p><a class="reference internal" href="#vsgetproperrors">VSGetPropErrors</a></p>
<p><a class="reference internal" href="#vspropappendmode">VSPropAppendMode</a></p>
<p><a class="reference internal" href="#vsactivationreason">VSActivationReason</a></p>
<p><a class="reference internal" href="#vsmessagetype">VSMessageType</a></p>
</dd>
<dt><a class="reference internal" href="#structs">Structs</a></dt><dd><p><a class="reference internal" href="#vsframeref">VSFrameRef</a></p>
<p><a class="reference internal" href="#vsnoderef">VSNodeRef</a></p>
<p><a class="reference internal" href="#vscore">VSCore</a></p>
<p><a class="reference internal" href="#vsplugin">VSPlugin</a></p>
<p><a class="reference internal" href="#vsnode">VSNode</a></p>
<p><a class="reference internal" href="#vsfuncref">VSFuncRef</a></p>
<p><a class="reference internal" href="#vsmap">VSMap</a></p>
<p><a class="reference internal" href="#vsframecontext">VSFrameContext</a></p>
<p><a class="reference internal" href="#vsformat">VSFormat</a></p>
<p><a class="reference internal" href="#vscoreinfo">VSCoreInfo</a></p>
<p><a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a></p>
<p><a class="reference internal" href="#vsapi">VSAPI</a></p>
<blockquote>
<div><ul>
<li><p>Functions that deal with the core:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#createcore">createCore</a></p></li>
<li><p><a class="reference internal" href="#freecore">freeCore</a></p></li>
<li><p><a class="reference internal" href="#getcoreinfo">getCoreInfo</a></p></li>
<li><p><a class="reference internal" href="#getcoreinfo2">getCoreInfo2</a></p></li>
<li><p><a class="reference internal" href="#setmaxcachesize">setMaxCacheSize</a></p></li>
<li><p><a class="reference internal" href="#setmessagehandler">setMessageHandler</a></p></li>
<li><p><a class="reference internal" href="#addmessagehandler">addMessageHandler</a></p></li>
<li><p><a class="reference internal" href="#removemessagehandler">removeMessageHandler</a></p></li>
<li><p><a class="reference internal" href="#logmessage">logMessage</a></p></li>
<li><p><a class="reference internal" href="#setthreadcount">setThreadCount</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with frames:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#newvideoframe">newVideoFrame</a></p></li>
<li><p><a class="reference internal" href="#newvideoframe2">newVideoFrame2</a></p></li>
<li><p><a class="reference internal" href="#copyframe">copyFrame</a></p></li>
<li><p><a class="reference internal" href="#cloneframeref">cloneFrameRef</a></p></li>
<li><p><a class="reference internal" href="#freeframe">freeFrame</a></p></li>
<li><p><a class="reference internal" href="#getstride">getStride</a></p></li>
<li><p><a class="reference internal" href="#getreadptr">getReadPtr</a></p></li>
<li><p><a class="reference internal" href="#getwriteptr">getWritePtr</a></p></li>
<li><p><a class="reference internal" href="#getframeformat">getFrameFormat</a></p></li>
<li><p><a class="reference internal" href="#getframewidth">getFrameWidth</a></p></li>
<li><p><a class="reference internal" href="#getframeheight">getFrameHeight</a></p></li>
<li><p><a class="reference internal" href="#copyframeprops">copyFrameProps</a></p></li>
<li><p><a class="reference internal" href="#getframepropsro">getFramePropsRO</a></p></li>
<li><p><a class="reference internal" href="#getframepropsrw">getFramePropsRW</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with nodes:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#clonenoderef">cloneNodeRef</a></p></li>
<li><p><a class="reference internal" href="#freenode">freeNode</a></p></li>
<li><p><a class="reference internal" href="#getframe">getFrame</a></p></li>
<li><p><a class="reference internal" href="#getframeasync">getFrameAsync</a></p></li>
<li><p><a class="reference internal" href="#getframefilter">getFrameFilter</a></p></li>
<li><p><a class="reference internal" href="#requestframefilter">requestFrameFilter</a></p></li>
<li><p><a class="reference internal" href="#getvideoinfo">getVideoInfo</a></p></li>
<li><p><a class="reference internal" href="#setvideoinfo">setVideoInfo</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with formats:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#getformatpreset">getFormatPreset</a></p></li>
<li><p><a class="reference internal" href="#registerformat">registerFormat</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with maps:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#createmap">createMap</a></p></li>
<li><p><a class="reference internal" href="#freemap">freeMap</a></p></li>
<li><p><a class="reference internal" href="#clearmap">clearMap</a></p></li>
<li><p><a class="reference internal" href="#seterror">setError</a></p></li>
<li><p><a class="reference internal" href="#geterror">getError</a></p></li>
<li><p><a class="reference internal" href="#propnumkeys">propNumKeys</a></p></li>
<li><p><a class="reference internal" href="#propgetkey">propGetKey</a></p></li>
<li><p><a class="reference internal" href="#propdeletekey">propDeleteKey</a></p></li>
<li><p><a class="reference internal" href="#propgettype">propGetType</a></p></li>
<li><p><a class="reference internal" href="#propnumelements">propNumElements</a></p></li>
<li><p><a class="reference internal" href="#propgetint">propGetInt</a></p></li>
<li><p><a class="reference internal" href="#propgetintarray">propGetIntArray</a></p></li>
<li><p><a class="reference internal" href="#propgetfloat">propGetFloat</a></p></li>
<li><p><a class="reference internal" href="#propgetfloatarray">propGetFloatArray</a></p></li>
<li><p><a class="reference internal" href="#propgetdata">propGetData</a></p></li>
<li><p><a class="reference internal" href="#propgetdatasize">propGetDataSize</a></p></li>
<li><p><a class="reference internal" href="#propgetnode">propGetNode</a></p></li>
<li><p><a class="reference internal" href="#propgetframe">propGetFrame</a></p></li>
<li><p><a class="reference internal" href="#propgetfunc">propGetFunc</a></p></li>
<li><p><a class="reference internal" href="#propsetint">propSetInt</a></p></li>
<li><p><a class="reference internal" href="#propsetintarray">propSetIntArray</a></p></li>
<li><p><a class="reference internal" href="#propsetfloat">propSetFloat</a></p></li>
<li><p><a class="reference internal" href="#propsetfloatarray">propSetFloatArray</a></p></li>
<li><p><a class="reference internal" href="#propsetdata">propSetData</a></p></li>
<li><p><a class="reference internal" href="#propsetnode">propSetNode</a></p></li>
<li><p><a class="reference internal" href="#propsetframe">propSetFrame</a></p></li>
<li><p><a class="reference internal" href="#propsetfunc">propSetFunc</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with plugins:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#getpluginbyid">getPluginById</a></p></li>
<li><p><a class="reference internal" href="#getpluginbyns">getPluginByNs</a></p></li>
<li><p><a class="reference internal" href="#getplugins">getPlugins</a></p></li>
<li><p><a class="reference internal" href="#getfunctions">getFunctions</a></p></li>
<li><p><a class="reference internal" href="#getpluginpath">getPluginPath</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that deal with functions:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#createfunc">createFunc</a></p></li>
<li><p><a class="reference internal" href="#clonefuncref">cloneFuncRef</a></p></li>
<li><p><a class="reference internal" href="#callfunc">callFunc</a></p></li>
<li><p><a class="reference internal" href="#freefunc">freeFunc</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that are mostly used in plugins:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#createfilter">createFilter</a></p></li>
<li><p><a class="reference internal" href="#registerfunction">registerFunction</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that resist classification:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#invoke">invoke</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Functions that are useful only in a filter’s getframe function,
but otherwise still resist classification:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#setfiltererror">setFilterError</a></p></li>
<li><p><a class="reference internal" href="#getoutputindex">getOutputIndex</a></p></li>
<li><p><a class="reference internal" href="#querycompletedframe">queryCompletedFrame</a></p></li>
<li><p><a class="reference internal" href="#releaseframeearly">releaseFrameEarly</a></p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</dd>
<dt><a class="reference internal" href="#functions">Functions</a></dt><dd><p><a class="reference internal" href="#getvapoursynthapi">getVapourSynthAPI</a></p>
</dd>
<dt><a class="reference internal" href="#writing-plugins">Writing plugins</a></dt><dd><p><a class="reference internal" href="#vsinitplugin">VSInitPlugin</a></p>
<p><a class="reference internal" href="#vsfilterinit">VSFilterInit</a></p>
<p><a class="reference internal" href="#vsfiltergetframe">VSFilterGetFrame</a></p>
<p><a class="reference internal" href="#vsfilterfree">VSFilterFree</a></p>
</dd>
</dl>
</section>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h2>
<p>This is VapourSynth’s main header file. Plugins and applications that use
the library must include it.</p>
<p>VapourSynth’s public API is all C.</p>
</section>
<section id="macros">
<h2>Macros<a class="headerlink" href="#macros" title="Permalink to this headline"></a></h2>
<p>VapourSynth.h defines some preprocessor macros that make the programmer’s life
easier. The relevant ones are described below.</p>
<section id="vs-cc">
<h3>VS_CC<a class="headerlink" href="#vs-cc" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">VS_CC</span></code> macro expands to the calling convention used by VapourSynth.
All functions meant to be called by VapourSynth must use this macro (a
filter’s “init”, “getframe”, “free” functions, etc).</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">VS_CC</span><span class="w"> </span><span class="nf">fooInit</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="vs-external-api">
<h3>VS_EXTERNAL_API<a class="headerlink" href="#vs-external-api" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">VS_EXTERNAL_API</span></code> macro expands to the platform-specific magic required
for functions exported by shared libraries. It also takes care of adding
<code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> when needed, and <code class="docutils literal notranslate"><span class="pre">VS_CC</span></code>.</p>
<p>This macro must be used for a plugin’s entry point, like so:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">VS_EXTERNAL_API</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">VapourSynthPluginInit</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="vapoursynth-api-major">
<h3>VAPOURSYNTH_API_MAJOR<a class="headerlink" href="#vapoursynth-api-major" title="Permalink to this headline"></a></h3>
<p>Major API version.</p>
<p>This macro was added in VapourSynth R26 (API R3).</p>
</section>
<section id="vapoursynth-api-minor">
<h3>VAPOURSYNTH_API_MINOR<a class="headerlink" href="#vapoursynth-api-minor" title="Permalink to this headline"></a></h3>
<p>Minor API version. It is bumped when new functions are added to <a class="reference internal" href="#vsapi">VSAPI</a>.</p>
<p>This macro was added in VapourSynth R26 (API R3).</p>
</section>
<section id="vapoursynth-api-version">
<h3>VAPOURSYNTH_API_VERSION<a class="headerlink" href="#vapoursynth-api-version" title="Permalink to this headline"></a></h3>
<p>API version. The high 16 bits are <a class="reference internal" href="#vapoursynth-api-major">VAPOURSYNTH_API_MAJOR</a>, the low 16
bits are <a class="reference internal" href="#vapoursynth-api-minor">VAPOURSYNTH_API_MINOR</a>.</p>
<p>Prior to VapourSynth R26, the API version consisted of only the major
component.</p>
</section>
</section>
<section id="enums">
<h2>Enums<a class="headerlink" href="#enums" title="Permalink to this headline"></a></h2>
<section id="enum-vscolorfamily">
<span id="vscolorfamily"></span><h3>enum VSColorFamily<a class="headerlink" href="#enum-vscolorfamily" title="Permalink to this headline"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>cmGray</p></li>
<li><p>cmRGB</p></li>
<li><p>cmYUV</p></li>
<li><p>cmYCoCg</p></li>
<li><p>cmCompat</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vssampletype">
<span id="vssampletype"></span><h3>enum VSSampleType<a class="headerlink" href="#enum-vssampletype" title="Permalink to this headline"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>stInteger</p></li>
<li><p>stFloat</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vspresetformat">
<span id="vspresetformat"></span><h3>enum VSPresetFormat<a class="headerlink" href="#enum-vspresetformat" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>The presets suffixed with H and S have floating point sample type.
The H and S suffixes stand for half precision and single precision,
respectively.</p>
<p>The compat formats are the only packed formats in VapourSynth. Everything
else is planar. They exist for compatibility with Avisynth plugins.
They are not to be implemented in native VapourSynth plugins.</p>
<ul class="simple">
<li><p>pfNone</p></li>
<li><p>pfGray8</p></li>
<li><p>pfGray16</p></li>
<li><p>pfGrayH</p></li>
<li><p>pfGrayS</p></li>
<li><p>pfYUV420P8</p></li>
<li><p>pfYUV422P8</p></li>
<li><p>pfYUV444P8</p></li>
<li><p>pfYUV410P8</p></li>
<li><p>pfYUV411P8</p></li>
<li><p>pfYUV440P8</p></li>
<li><p>pfYUV420P9</p></li>
<li><p>pfYUV422P9</p></li>
<li><p>pfYUV444P9</p></li>
<li><p>pfYUV420P10</p></li>
<li><p>pfYUV422P10</p></li>
<li><p>pfYUV444P10</p></li>
<li><p>pfYUV420P12</p></li>
<li><p>pfYUV422P12</p></li>
<li><p>pfYUV444P12</p></li>
<li><p>pfYUV420P14</p></li>
<li><p>pfYUV422P14</p></li>
<li><p>pfYUV444P14</p></li>
<li><p>pfYUV420P16</p></li>
<li><p>pfYUV422P16</p></li>
<li><p>pfYUV444P16</p></li>
<li><p>pfYUV444PH</p></li>
<li><p>pfYUV444PS</p></li>
<li><p>pfRGB24</p></li>
<li><p>pfRGB27</p></li>
<li><p>pfRGB30</p></li>
<li><p>pfRGB48</p></li>
<li><p>pfRGBH</p></li>
<li><p>pfRGBS</p></li>
<li><p>pfCompatBGR32</p></li>
<li><p>pfCompatYUY2</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsfiltermode">
<span id="vsfiltermode"></span><h3>enum VSFilterMode<a class="headerlink" href="#enum-vsfiltermode" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>Controls how a filter will be multithreaded, if at all.</p>
<ul>
<li><p>fmParallel</p>
<p>Completely parallel execution.
Multiple threads will call a filter’s “getframe” function, to fetch several
frames in parallel.</p>
</li>
<li><p>fmParallelRequests</p>
<p>For filters that are serial in nature but can request in advance one or
more frames they need.
A filter’s “getframe” function will be called from multiple threads at a
time with activation reason arInitial, but only one thread will call it
with activation reason arAllFramesReady at a time.</p>
</li>
<li><p>fmUnordered</p>
<p>Only one thread can call the filter’s “getframe” function at a time.
Useful for filters that modify or examine their internal state to
determine which frames to request.</p>
<p>While the “getframe” function will only run in one thread at a
time, the calls can happen in any order. For example, it can be
called with reason arInitial for frame 0, then again with reason
arInitial for frame 1, then with reason arAllFramesReady for
frame 0.</p>
</li>
<li><p>fmSerial</p>
<p>For compatibility with other filtering architectures.
The filter’s “getframe” function only ever gets called from one thread at a
time. Unlike fmUnordered, only one frame is processed at a time.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsnodeflags">
<span id="vsnodeflags"></span><h3>enum VSNodeFlags<a class="headerlink" href="#enum-vsnodeflags" title="Permalink to this headline"></a></h3>
<blockquote>
<div><ul>
<li><p>nfNoCache</p>
<p>This flag indicates that the frames returned by the filter should not
be cached. “Fast” filters should set this to reduce cache bloat.</p>
</li>
<li><p>nfIsCache</p>
<p>This flag must not be used in third-party filters. It is used to mark
instances of the built-in Cache filter. Strange things may happen to
your filter if you use this flag.</p>
<p>This flag was introduced in VapourSynth R24 without bumping the
API version (R3).</p>
</li>
<li><p>nfMakeLinear</p>
<p>This flag should be used by filters which prefer linear access,
like source filters, where seeking around can cause significant
slowdowns. This flag only has any effect if the filter using it
is immediately followed by an instance of the built-in Cache filter.</p>
<p>This flag was introduced in API R3.3 (VapourSynth R30).</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsproptypes">
<span id="vsproptypes"></span><h3>enum VSPropTypes<a class="headerlink" href="#enum-vsproptypes" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>Types of properties that can be stored in a VSMap.</p>
<ul class="simple">
<li><p>ptUnset</p></li>
<li><p>ptInt</p></li>
<li><p>ptFloat</p></li>
<li><p>ptData</p></li>
<li><p>ptNode</p></li>
<li><p>ptFrame</p></li>
<li><p>ptFunction</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsgetproperrors">
<span id="vsgetproperrors"></span><h3>enum VSGetPropErrors<a class="headerlink" href="#enum-vsgetproperrors" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>When a propGet* function fails, it returns one of these in the <em>err</em>
parameter.</p>
<p>They are all non-zero.</p>
<ul>
<li><p>peUnset</p>
<p>The requested key was not found in the map.</p>
</li>
<li><p>peType</p>
<p>The wrong function was used to retrieve the property. E.g.
<a class="reference internal" href="#propgetint">propGetInt</a>() was used on a property of type ptFloat.</p>
</li>
<li><p>peIndex</p>
<p>The requested index was out of bounds.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="enum-vspropappendmode">
<span id="vspropappendmode"></span><h3>enum VSPropAppendMode<a class="headerlink" href="#enum-vspropappendmode" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>Controls the behaviour of <a class="reference internal" href="#propsetint">propSetInt</a>() and friends.</p>
<ul>
<li><p>paReplace</p>
<p>All existing values associated with the key will be replaced with
the new value.</p>
</li>
<li><p>paAppend</p>
<p>The new value will be appended to the list of existing values
associated with the key.</p>
</li>
<li><p>paTouch</p>
<p>If the key exists in the map, nothing happens. Otherwise, the key
is added to the map, with no values associated.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsactivationreason">
<span id="vsactivationreason"></span><h3>enum VSActivationReason<a class="headerlink" href="#enum-vsactivationreason" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>See <a class="reference internal" href="#vsfiltergetframe">VSFilterGetFrame</a>.</p>
<ul class="simple">
<li><p>arInitial</p></li>
<li><p>arFrameReady</p></li>
<li><p>arAllFramesReady</p></li>
<li><p>arError</p></li>
</ul>
</div></blockquote>
</section>
<section id="enum-vsmessagetype">
<span id="vsmessagetype"></span><h3>enum VSMessageType<a class="headerlink" href="#enum-vsmessagetype" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>See <a class="reference internal" href="#setmessagehandler">setMessageHandler</a>().</p>
<ul class="simple">
<li><p>mtDebug</p></li>
<li><p>mtWarning</p></li>
<li><p>mtCritical</p></li>
<li><p>mtFatal</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="structs">
<h2>Structs<a class="headerlink" href="#structs" title="Permalink to this headline"></a></h2>
<p>Most structs are opaque and their contents can only be accessed using functions in the API.</p>
<section id="struct-vsframeref">
<span id="vsframeref"></span><h3>struct VSFrameRef<a class="headerlink" href="#struct-vsframeref" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>A frame.</p>
<p>Each row of pixels in a frame is guaranteed to have an alignment of 32
bytes.</p>
<p>Two frames with the same width are guaranteed to have the same stride.</p>
<p>Any data can be attached to a frame, using a <a class="reference internal" href="#vsmap">VSMap</a>.</p>
</div></blockquote>
</section>
<section id="struct-vsnoderef">
<span id="vsnoderef"></span><h3>struct VSNodeRef<a class="headerlink" href="#struct-vsnoderef" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>A reference to a node in the constructed filter graph. Its primary use
is as an argument to other filter or to request frames from.</p>
</div></blockquote>
</section>
<section id="struct-vscore">
<span id="vscore"></span><h3>struct VSCore<a class="headerlink" href="#struct-vscore" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>The core represents one instance of VapourSynth. Every core individually
loads plugins and keeps track of memory.</p>
</div></blockquote>
</section>
<section id="struct-vsplugin">
<span id="vsplugin"></span><h3>struct VSPlugin<a class="headerlink" href="#struct-vsplugin" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>A VapourSynth plugin. There are a few of these built into the core,
and therefore available at all times: the basic filters (identifier
<code class="docutils literal notranslate"><span class="pre">com.vapoursynth.std</span></code>, namespace <code class="docutils literal notranslate"><span class="pre">std</span></code>), the resizers (identifier
<code class="docutils literal notranslate"><span class="pre">com.vapoursynth.resize</span></code>, namespace <code class="docutils literal notranslate"><span class="pre">resize</span></code>), and the Avisynth
compatibility module, if running in Windows (identifier
<code class="docutils literal notranslate"><span class="pre">com.vapoursynth.avisynth</span></code>, namespace <code class="docutils literal notranslate"><span class="pre">avs</span></code>).</p>
<p>The Function Reference describes how to load VapourSynth and Avisynth
plugins.</p>
<p>A VSPlugin instance is constructed by the core when loading a plugin
(.so / .dylib / .dll), and the pointer is passed to the plugin’s
VapourSynthPluginInit() function.</p>
<p>A VapourSynth plugin can export any number of filters.</p>
<p>Plugins have a few attributes:</p>
<blockquote>
<div><ul class="simple">
<li><p>An identifier, which must be unique among all VapourSynth plugins in
existence, because this is what the core uses to make sure a plugin
only gets loaded once.</p></li>
<li><p>A namespace, also unique. The filters exported by a plugin end up in
the plugin’s namespace.</p></li>
<li><p>A full name, which is used by the core in a few error messages.</p></li>
<li><p>The VapourSynth API version the plugin requires.</p></li>
<li><p>A file name.</p></li>
</ul>
</div></blockquote>
<p>Things you can do with a VSPlugin:</p>
<blockquote>
<div><ul class="simple">
<li><p>Get a list of all the filters it exports, using <a class="reference internal" href="#getfunctions">getFunctions</a>().</p></li>
<li><p>Invoke one of its filters, using <a class="reference internal" href="#invoke">invoke</a>().</p></li>
<li><p>Get its location in the file system, using <a class="reference internal" href="#getpluginpath">getPluginPath</a>().</p></li>
</ul>
</div></blockquote>
<p>A list of all loaded plugins (including built-in) can be obtained with
<a class="reference internal" href="#getplugins">getPlugins</a>().</p>
<p>Once loaded, a plugin only gets unloaded when the VapourSynth core is freed.</p>
</div></blockquote>
</section>
<section id="struct-vsnode">
<span id="vsnode"></span><h3>struct VSNode<a class="headerlink" href="#struct-vsnode" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>Not really interesting.</p>
</div></blockquote>
</section>
<section id="struct-vsfuncref">
<span id="vsfuncref"></span><h3>struct VSFuncRef<a class="headerlink" href="#struct-vsfuncref" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>Holds a reference to a function that may be called. This type primarily exists
so functions can be shared between the scripting layer and plugins in the core.</p>
</div></blockquote>
</section>
<section id="struct-vsmap">
<span id="vsmap"></span><h3>struct VSMap<a class="headerlink" href="#struct-vsmap" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>VSMap is a container that stores (key,value) pairs. The keys are strings
and the values can be (arrays of) integers, floating point numbers,
arrays of bytes, <a class="reference internal" href="#vsnoderef">VSNodeRef</a>, <a class="reference internal" href="#vsframeref">VSFrameRef</a>, or <a class="reference internal" href="#vsfuncref">VSFuncRef</a>.</p>
<p>The pairs in a VSMap are sorted by key.</p>
<dl class="simple">
<dt>In VapourSynth, VSMaps have several uses:</dt><dd><ul class="simple">
<li><p>storing filters’ arguments and return values</p></li>
<li><p>storing user-defined functions’ arguments and return values</p></li>
<li><p>storing the properties attached to frames</p></li>
</ul>
</dd>
</dl>
<p>Only alphanumeric characters and the underscore may be used in keys.</p>
<p>Creating and destroying a map can be done with <a class="reference internal" href="#createmap">createMap</a>() and
<a class="reference internal" href="#freemap">freeMap</a>(), respectively.</p>
<p>A map’s contents can be retrieved and modified using a number of functions,
all prefixed with “prop”.</p>
<p>A map’s contents can be erased with <a class="reference internal" href="#clearmap">clearMap</a>().</p>
</div></blockquote>
</section>
<section id="struct-vsframecontext">
<span id="vsframecontext"></span><h3>struct VSFrameContext<a class="headerlink" href="#struct-vsframecontext" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>Not really interesting.</p>
</div></blockquote>
</section>
<section id="struct-vsformat">
<span id="vsformat"></span><h3>struct VSFormat<a class="headerlink" href="#struct-vsformat" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>Describes the format of a clip.</p>
<p>Don’t create an instance of this struct manually (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">VSFormat</span> <span class="pre">moo;</span></code>),
but only through <a class="reference internal" href="#registerformat">registerFormat</a>(). Registered VSFormat instances will be
valid as long as the VapourSynth core object lives. They can be retrieved
with <a class="reference internal" href="#getformatpreset">getFormatPreset</a>() or <a class="reference internal" href="#registerformat">registerFormat</a>().</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.name">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">name</span></span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">32</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#c.name" title="Permalink to this definition"></a><br /></dt>
<dd><p>A nice, printable name, like “YUV444P10”.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.id">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">id</span></span></span><a class="headerlink" href="#c.id" title="Permalink to this definition"></a><br /></dt>
<dd><p>A number that uniquely identifies the VSFormat instance. One of
<a class="reference internal" href="#vspresetformat">VSPresetFormat</a>, if it’s a built-in format.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.colorFamily">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">colorFamily</span></span></span><a class="headerlink" href="#c.colorFamily" title="Permalink to this definition"></a><br /></dt>
<dd><p>See <a class="reference internal" href="#vscolorfamily">VSColorFamily</a>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.sampleType">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sampleType</span></span></span><a class="headerlink" href="#c.sampleType" title="Permalink to this definition"></a><br /></dt>
<dd><p>See <a class="reference internal" href="#vssampletype">VSSampleType</a>.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.bitsPerSample">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bitsPerSample</span></span></span><a class="headerlink" href="#c.bitsPerSample" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of significant bits.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.bytesPerSample">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">bytesPerSample</span></span></span><a class="headerlink" href="#c.bytesPerSample" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of bytes needed for a sample. This is always a power of 2 and the
smallest possible that can fit the number of bits used per sample.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.subSamplingW">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">subSamplingW</span></span></span><a class="headerlink" href="#c.subSamplingW" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.subSamplingH">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">subSamplingH</span></span></span><a class="headerlink" href="#c.subSamplingH" title="Permalink to this definition"></a><br /></dt>
<dd><p>log2 subsampling factor, applied to second and third plane.
Convenient numbers that can be used like so:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">uv_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y_width</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">subSamplingW</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.numPlanes">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numPlanes</span></span></span><a class="headerlink" href="#c.numPlanes" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of planes.</p>
</dd></dl>

</div></blockquote>
</section>
<section id="struct-vscoreinfo">
<span id="vscoreinfo"></span><h3>struct VSCoreInfo<a class="headerlink" href="#struct-vscoreinfo" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>Contains information about a <a class="reference internal" href="#vscore">VSCore</a> instance.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.versionString">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">versionString</span></span></span><a class="headerlink" href="#c.versionString" title="Permalink to this definition"></a><br /></dt>
<dd><p>Printable string containing the name of the library, copyright notice,
core and API versions.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.core">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">core</span></span></span><a class="headerlink" href="#c.core" title="Permalink to this definition"></a><br /></dt>
<dd><p>Version of the core.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.api">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">api</span></span></span><a class="headerlink" href="#c.api" title="Permalink to this definition"></a><br /></dt>
<dd><p>Version of the API.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.numThreads">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numThreads</span></span></span><a class="headerlink" href="#c.numThreads" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of worker threads.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.maxFramebufferSize">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">maxFramebufferSize</span></span></span><a class="headerlink" href="#c.maxFramebufferSize" title="Permalink to this definition"></a><br /></dt>
<dd><p>The framebuffer cache will be allowed to grow up to this size (bytes) before memory is aggressively reclaimed.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.usedFramebufferSize">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">usedFramebufferSize</span></span></span><a class="headerlink" href="#c.usedFramebufferSize" title="Permalink to this definition"></a><br /></dt>
<dd><p>Current size of the framebuffer cache, in bytes.</p>
</dd></dl>

</div></blockquote>
</section>
<section id="struct-vsvideoinfo">
<span id="vsvideoinfo"></span><h3>struct VSVideoInfo<a class="headerlink" href="#struct-vsvideoinfo" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>Contains information about a clip.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.format">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">VSFormat</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">format</span></span></span><a class="headerlink" href="#c.format" title="Permalink to this definition"></a><br /></dt>
<dd><p>Format of the clip. It will be NULL if the clip’s format can vary.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.fpsNum">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fpsNum</span></span></span><a class="headerlink" href="#c.fpsNum" title="Permalink to this definition"></a><br /></dt>
<dd><p>Numerator part of the clip’s frame rate. It will be 0 if the frame
rate can vary. Should always be a reduced fraction.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.fpsDen">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fpsDen</span></span></span><a class="headerlink" href="#c.fpsDen" title="Permalink to this definition"></a><br /></dt>
<dd><p>Denominator part of the clip’s frame rate. It will be 0 if the frame
rate can vary. Should always be a reduced fraction.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.width">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">width</span></span></span><a class="headerlink" href="#c.width" title="Permalink to this definition"></a><br /></dt>
<dd><p>Width of the clip. Both width and height will be 0 if the clip’s dimensions can vary.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.height">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">height</span></span></span><a class="headerlink" href="#c.height" title="Permalink to this definition"></a><br /></dt>
<dd><p>Height of the clip. Both width and height will be 0 if the clip’s dimensions can vary.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.numFrames">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">numFrames</span></span></span><a class="headerlink" href="#c.numFrames" title="Permalink to this definition"></a><br /></dt>
<dd><p>Length of the clip.</p>
<p>Since API R3.2 (VapourSynth R27) this is no longer allowed to be 0,
i.e. clips with unknown length are not supported.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.flags">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flags</span></span></span><a class="headerlink" href="#c.flags" title="Permalink to this definition"></a><br /></dt>
<dd><p>The flags passed to <a class="reference internal" href="#createfilter">createFilter</a> (either 0, or one or more of
<a class="reference internal" href="#vsnodeflags">VSNodeFlags</a>).</p>
</dd></dl>

</div></blockquote>
</section>
<section id="struct-vsapi">
<span id="vsapi"></span><h3>struct VSAPI<a class="headerlink" href="#struct-vsapi" title="Permalink to this headline"></a></h3>
<blockquote>
<div><p>This giant struct is the way to access VapourSynth’s public API.</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createcore"><a class="reference internal" href="#vscore">VSCore</a> *createCore(int threads)</p>
<blockquote>
<div><p>Creates the VapourSynth processing core and returns a pointer to it. It is
legal to create multiple cores but in most cases it shouldn’t be needed.</p>
<dl class="simple">
<dt><em>threads</em></dt><dd><p>Number of desired worker threads. If 0 or lower, a suitable value is
automatically chosen, based on the number of logical CPUs.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="freecore">void freeCore(<a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Frees a core. Should only be done after all frame requests have completed
and all objects belonging to the core have been released.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getcoreinfo">const <a class="reference internal" href="#vscoreinfo">VSCoreInfo</a> *getCoreInfo(<a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Deprecated as of API 3.6 (VapourSynth R47)</p>
<p>Returns information about the VapourSynth core.</p>
<p>VapourSynth retains ownership of the returned pointer.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getcoreinfo2">void getCoreInfo2(<a class="reference internal" href="#vscore">VSCore</a> *core, <a class="reference internal" href="#vscoreinfo">VSCoreInfo</a> *info)</p>
<blockquote>
<div><p>Returns information about the VapourSynth core.</p>
<p>This function is thread-safe.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setmaxcachesize">int64_t setMaxCacheSize(int64_t bytes, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Sets the maximum size of the framebuffer cache. Returns the new maximum
size.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setmessagehandler">void setMessageHandler(VSMessageHandler handler, void *userData)</p>
<blockquote>
<div><p>Deprecated as of API 3.6 (VapourSynth R47)</p>
<p>Installs a custom handler for the various error messages VapourSynth
emits. The message handler is currently global, i.e. per process, not
per <a class="reference internal" href="#vscore">VSCore</a> instance.</p>
<p>The default message handler simply sends the messages to the
standard error stream.</p>
<p>This function is thread-safe.</p>
<dl>
<dt><em>handler</em></dt><dd><p>typedef void (VS_CC *VSMessageHandler)(int msgType, const char *msg, void *userdata)</p>
<p>Custom message handler. If this is NULL, the default message
handler will be restored.</p>
<dl>
<dt><em>msgType</em></dt><dd><p>The type of message. One of <a class="reference internal" href="#vsmessagetype">VSMessageType</a>.</p>
<p>If <em>msgType</em> is mtFatal, VapourSynth will call abort() after the
message handler returns.</p>
</dd>
<dt><em>msg</em></dt><dd><p>The message.</p>
</dd>
</dl>
</dd>
<dt><em>userData</em></dt><dd><p>Pointer that gets passed to the message handler.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="addmessagehandler">int addMessageHandler(VSMessageHandler handler, VSMessageHandlerFree free, void *userData)</p>
<blockquote>
<div><p>Installs a custom handler for the various error messages VapourSynth
emits. The message handler is currently global, i.e. per process, not
per <a class="reference internal" href="#vscore">VSCore</a> instance. Returns a unique id for the handler.</p>
<p>If no error handler is installed the messages are sent to the
standard error stream.</p>
<p>This function is thread-safe.</p>
<dl>
<dt><em>handler</em></dt><dd><p>typedef void (VS_CC *VSMessageHandler)(int msgType, const char *msg, void *userdata)</p>
<p>Custom message handler. If this is NULL, the default message
handler will be restored.</p>
<dl>
<dt><em>msgType</em></dt><dd><p>The type of message. One of <a class="reference internal" href="#vsmessagetype">VSMessageType</a>.</p>
<p>If <em>msgType</em> is mtFatal, VapourSynth will call abort() after the
message handler returns.</p>
</dd>
<dt><em>msg</em></dt><dd><p>The message.</p>
</dd>
</dl>
</dd>
<dt><em>free</em></dt><dd><p>typedef void (VS_CC *VSMessageHandlerFree)(void *userData)</p>
<p>Called when a handler is removed.</p>
</dd>
<dt><em>userData</em></dt><dd><p>Pointer that gets passed to the message handler.</p>
</dd>
</dl>
<p>This function was introduced in API R3.6 (VapourSynth R47).</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="removemessagehandler">int removeMessageHandler(int id)</p>
<blockquote>
<div><p>Removes a custom handler. Return non-zero on success and zero if
the handler id is invalid.</p>
<p>This function is thread-safe.</p>
<dl class="simple">
<dt><em>id</em></dt><dd><p>Message handler id obtained from <a class="reference internal" href="#addmessagehandler">addMessageHandler</a>().</p>
</dd>
</dl>
<p>This function was introduced in API R3.6 (VapourSynth R47).</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="logmessage">void logMessage(int msgType, const char *msg)</p>
<blockquote>
<div><p>Send a message through VapourSynth’s logging framework. See
<a class="reference internal" href="#setmessagehandler">setMessageHandler</a>.</p>
<p>This function is thread-safe.</p>
<dl>
<dt><em>msgType</em></dt><dd><p>The type of message. One of <a class="reference internal" href="#vsmessagetype">VSMessageType</a>.</p>
<p>If <em>msgType</em> is mtFatal, VapourSynth will call abort() after
delivering the message.</p>
</dd>
<dt><em>msg</em></dt><dd><p>The message.</p>
</dd>
</dl>
<p>This function was introduced in API R3.4 (VapourSynth R30).</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setthreadcount">int setThreadCount(int threads, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Sets the number of worker threads for the given core. If the requested
number of threads is zero or lower, the number of hardware threads will
be detected and used.</p>
<p>Returns the new thread count.</p>
<p>This function was introduced in VapourSynth R24 without bumping
the API version (R3).</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="newvideoframe"><a class="reference internal" href="#vsframeref">VSFrameRef</a> *newVideoFrame(const <a class="reference internal" href="#vsformat">VSFormat</a> *format, int width, int height, const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *propSrc, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Creates a new frame, optionally copying the properties attached to another
frame. It is a fatal error to pass invalid arguments to this function.</p>
<p>The new frame contains uninitialised memory.</p>
<dl class="simple">
<dt><em>format</em></dt><dd><p>The desired colorspace format. Must not be NULL.</p>
</dd>
</dl>
<p><em>width</em></p>
<dl class="simple">
<dt><em>height</em></dt><dd><p>The desired dimensions of the frame, in pixels. Must be greater than 0 and have a suitable multiple for the subsampling in format.</p>
</dd>
<dt><em>propSrc</em></dt><dd><p>A frame from which properties will be copied. Can be NULL.</p>
</dd>
</dl>
<p>Returns a pointer to the created frame. Ownership of the new frame is
transferred to the caller.</p>
<p>See also <a class="reference internal" href="#newvideoframe2">newVideoFrame2</a>().</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="newvideoframe2"><a class="reference internal" href="#vsframeref">VSFrameRef</a> *newVideoFrame2(const <a class="reference internal" href="#vsformat">VSFormat</a> *format, int width, int height, const <a class="reference internal" href="#vsframeref">VSFrameRef</a> **planeSrc, const int *planes, const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *propSrc, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Creates a new frame from the planes of existing frames, optionally copying
the properties attached to another frame. It is a fatal error to pass invalid arguments to this function.</p>
<dl class="simple">
<dt><em>format</em></dt><dd><p>The desired colorspace format. Must not be NULL.</p>
</dd>
</dl>
<p><em>width</em></p>
<dl class="simple">
<dt><em>height</em></dt><dd><p>The desired dimensions of the frame, in pixels. Must be greater than 0 and have a suitable multiple for the subsampling in format.</p>
</dd>
<dt><em>planeSrc</em></dt><dd><p>Array of frames from which planes will be copied. If any elements of
the array are NULL, the corresponding planes in the new frame will
contain uninitialised memory.</p>
</dd>
<dt><em>planes</em></dt><dd><p>Array of plane numbers indicating which plane to copy from the
corresponding source frame.</p>
</dd>
<dt><em>propSrc</em></dt><dd><p>A frame from which properties will be copied. Can be NULL.</p>
</dd>
</dl>
<p>Returns a pointer to the created frame. Ownership of the new frame is
transferred to the caller.</p>
<p>Example (assume <em>frameA</em>, <em>frameB</em>, <em>frameC</em> are existing frames):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">VSFrameRef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">frames</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">frameA</span><span class="p">,</span><span class="w"> </span><span class="n">frameB</span><span class="p">,</span><span class="w"> </span><span class="n">frameC</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">planes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">VSFrameRef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">newFrame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vsapi</span><span class="o">-&gt;</span><span class="n">newVideoFrame2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">frames</span><span class="p">,</span><span class="w"> </span><span class="n">planes</span><span class="p">,</span><span class="w"> </span><span class="n">frameB</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The newFrame’s first plane is now a copy of <em>frameA</em>’s second plane,
the second plane is a copy of <em>frameB</em>’s first plane,
the third plane is a copy of <em>frameC</em>’s third plane
and the properties have been copied from <em>frameB</em>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="copyframe"><a class="reference internal" href="#vsframeref">VSFrameRef</a> *copyFrame(const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Duplicates the frame (not just the reference). As the frame buffer is
shared in a copy-on-write fashion, the frame content is not really
duplicated until a write operation occurs. This is transparent for the user.</p>
<p>Returns a pointer to the new frame. Ownership is transferred to the caller.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="cloneframeref">const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *cloneFrameRef(const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f)</p>
<blockquote>
<div><p>Duplicates a frame reference. This new reference has to be deleted with
<a class="reference internal" href="#freeframe">freeFrame</a>() when it is no longer needed.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="freeframe">void freeFrame(const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f)</p>
<blockquote>
<div><p>Deletes a frame reference, releasing the caller’s ownership of the frame.</p>
<p>It is safe to pass NULL.</p>
<p>Don’t try to use the frame once the reference has been deleted.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getstride">int getStride(const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f, int plane)</p>
<blockquote>
<div><p>Returns the distance in bytes between two consecutive lines of a plane of
a frame. The stride is always positive.</p>
<p>Passing an invalid plane number will cause a fatal error.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getreadptr">const uint8_t *getReadPtr(const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f, int plane)</p>
<blockquote>
<div><p>Returns a read-only pointer to a plane of a frame.</p>
<p>Passing an invalid plane number will cause a fatal error.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Don’t assume all three planes of a frame are allocated in one
contiguous chunk (they’re not).</p>
</div>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getwriteptr">uint8_t *getWritePtr(<a class="reference internal" href="#vsframeref">VSFrameRef</a> *f, int plane)</p>
<blockquote>
<div><p>Returns a read/write pointer to a plane of a frame.</p>
<p>Passing an invalid plane number will cause a fatal error.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Don’t assume all three planes of a frame are allocated in one
contiguous chunk (they’re not).</p>
</div>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframeformat">const <a class="reference internal" href="#vsformat">VSFormat</a> *getFrameFormat(const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f)</p>
<blockquote>
<div><p>Retrieves the format of a frame.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframewidth">int getFrameWidth(const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f, int plane)</p>
<blockquote>
<div><p>Returns the width of a plane of a given frame, in pixels. The width
depends on the plane number because of the possible chroma subsampling.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframeheight">int getFrameHeight(const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f, int plane)</p>
<blockquote>
<div><p>Returns the height of a plane of a given frame, in pixels. The height
depends on the plane number because of the possible chroma subsampling.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="copyframeprops">void copyFrameProps(const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *src, <a class="reference internal" href="#vsframeref">VSFrameRef</a> *dst, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Copies the property map of a frame to another frame, overwriting all
existing properties.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframepropsro">const <a class="reference internal" href="#vsmap">VSMap</a> *getFramePropsRO(const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f)</p>
<blockquote>
<div><p>Returns a read-only pointer to a frame’s properties. The pointer is valid
as long as the frame lives.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframepropsrw"><a class="reference internal" href="#vsmap">VSMap</a> *getFramePropsRW(<a class="reference internal" href="#vsframeref">VSFrameRef</a> *f)</p>
<blockquote>
<div><p>Returns a read/write pointer to a frame’s properties. The pointer is valid
as long as the frame lives.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="clonenoderef"><a class="reference internal" href="#vsnoderef">VSNodeRef</a> *cloneNodeRef(<a class="reference internal" href="#vsnoderef">VSNodeRef</a> *node)</p>
<blockquote>
<div><p>Duplicates a node reference. This new reference has to be deleted with
<a class="reference internal" href="#freenode">freeNode</a>() when it is no longer needed.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="freenode">void freeNode(<a class="reference internal" href="#vsnoderef">VSNodeRef</a> *node)</p>
<blockquote>
<div><p>Deletes a node reference, releasing the caller’s ownership of the node.</p>
<p>It is safe to pass NULL.</p>
<p>Don’t try to use the node once the reference has been deleted.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframe">const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *getFrame(int n, <a class="reference internal" href="#vsnoderef">VSNodeRef</a> *node, char *errorMsg, int bufSize)</p>
<blockquote>
<div><p>Generates a frame directly. The frame is available when the function
returns.</p>
<p>This function is meant for external applications using the core as a
library, or if frame requests are necessary during a filter’s
initialization.</p>
<p>Thread-safe.</p>
<dl class="simple">
<dt><em>n</em></dt><dd><p>The frame number. Negative values will cause an error.</p>
</dd>
<dt><em>node</em></dt><dd><p>The node from which the frame is requested.</p>
</dd>
<dt><em>errorMsg</em></dt><dd><p>Pointer to a buffer of <em>bufSize</em> bytes to store a possible error
message. Can be NULL if no error message is wanted.</p>
</dd>
<dt><em>bufSize</em></dt><dd><p>Maximum length for the error message, in bytes (including the
trailing ‘0’). Can be 0 if no error message is wanted.</p>
</dd>
</dl>
<p>Returns a reference to the generated frame, or NULL in case of failure.
The ownership of the frame is transferred to the caller.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Never use inside a filter’s “getframe” function.</p>
</div>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframeasync">void getFrameAsync(int n, <a class="reference internal" href="#vsnoderef">VSNodeRef</a> *node, VSFrameDoneCallback callback, void *userData)</p>
<blockquote>
<div><p>Requests the generation of a frame. When the frame is ready,
a user-provided function is called.</p>
<p>This function is meant for applications using VapourSynth as a library.</p>
<p>Thread-safe.</p>
<dl>
<dt><em>n</em></dt><dd><p>Frame number. Negative values will cause an error.</p>
</dd>
<dt><em>node</em></dt><dd><p>The node from which the frame is requested.</p>
</dd>
<dt><em>callback</em></dt><dd><p>typedef void (VS_CC *VSFrameDoneCallback)(void *userData, const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f, int n, <a class="reference internal" href="#vsnoderef">VSNodeRef</a> *node, const char *errorMsg)</p>
<p>Function of the client application called by the core when a requested
frame is ready, after a call to getFrameAsync().</p>
<p>If multiple frames were requested, they can be returned in any order.
Client applications must take care of reordering them.</p>
<p>This function is only ever called from one thread at a time.</p>
<p>getFrameAsync() may be called from this function to request more
frames.</p>
<dl class="simple">
<dt><em>userData</em></dt><dd><p>Pointer to private data from the client application, as passed
previously to getFrameAsync().</p>
</dd>
<dt><em>f</em></dt><dd><p>Contains a reference to the generated frame, or NULL in case of failure.
The ownership of the frame is transferred to the caller.</p>
</dd>
<dt><em>n</em></dt><dd><p>The frame number.</p>
</dd>
<dt><em>node</em></dt><dd><p>Node the frame belongs to.</p>
</dd>
<dt><em>errorMsg</em></dt><dd><p>String that usually contains an error message if the frame
generation failed. NULL if there is no error.</p>
</dd>
</dl>
</dd>
<dt><em>userData</em></dt><dd><p>Pointer passed to the callback.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Never use inside a filter’s “getframe” function.</p>
</div>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getframefilter">const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *getFrameFilter(int n, <a class="reference internal" href="#vsnoderef">VSNodeRef</a> *node, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><p>Retrieves a frame that was previously requested with
<a class="reference internal" href="#requestframefilter">requestFrameFilter</a>().</p>
<p>Only use inside a filter’s “getframe” function.</p>
<p>A filter usually calls this function when its activation reason is
arAllFramesReady or arFrameReady. See <a class="reference internal" href="#vsactivationreason">VSActivationReason</a>.</p>
<p>It is safe to retrieve a frame more than once, but each reference
needs to be freed.</p>
<dl class="simple">
<dt><em>n</em></dt><dd><p>The frame number.</p>
</dd>
<dt><em>node</em></dt><dd><p>The node from which the frame is retrieved.</p>
</dd>
<dt><em>frameCtx</em></dt><dd><p>The context passed to the filter’s “getframe” function.</p>
</dd>
</dl>
<p>Returns a pointer to the requested frame, or NULL if the requested frame
is not available for any reason. The ownership of the frame is
transferred to the caller.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="requestframefilter">void requestFrameFilter(int n, <a class="reference internal" href="#vsnoderef">VSNodeRef</a> *node, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><p>Requests a frame from a node and returns immediately.</p>
<p>Only use inside a filter’s “getframe” function.</p>
<p>A filter usually calls this function when its activation reason is
arInitial. The requested frame can then be retrieved using
<a class="reference internal" href="#getframefilter">getFrameFilter</a>(), when the filter’s activation reason is
arAllFramesReady or arFrameReady. See <a class="reference internal" href="#vsactivationreason">VSActivationReason</a>.</p>
<p>It is safe to request a frame more than once. An unimportant consequence
of requesting a frame more than once is that the getframe function may
be called more than once for the same frame with reason arFrameReady.</p>
<p>It is best to request frames in ascending order, i.e. n, n+1, n+2, etc.</p>
<dl class="simple">
<dt><em>n</em></dt><dd><p>The frame number. Negative values will cause an error.</p>
</dd>
<dt><em>node</em></dt><dd><p>The node from which the frame is requested.</p>
</dd>
<dt><em>frameCtx</em></dt><dd><p>The context passed to the filter’s “getframe” function.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getvideoinfo">const <a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a> *getVideoInfo(<a class="reference internal" href="#vsnoderef">VSNodeRef</a> *node)</p>
<blockquote>
<div><p>Returns a pointer to the video info associated with a node. The pointer is
valid as long as the node lives.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setvideoinfo">void setVideoInfo(const <a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a> *vi, int numOutputs, <a class="reference internal" href="#vsnode">VSNode</a> *node)</p>
<blockquote>
<div><p>Sets the node’s video info.</p>
<dl class="simple">
<dt><em>vi</em></dt><dd><p>Pointer to <em>numOutputs</em> <a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a> instances. The structures are
copied by the core. The flags are however ignored and replaced by the
flags passed to _createFilter.</p>
</dd>
<dt><em>numOutputs</em></dt><dd><p>Number of clips the filter wants to return. Must be greater than 0.</p>
</dd>
<dt><em>node</em></dt><dd><p>Pointer to the node whose video info is to be set.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getformatpreset">const <a class="reference internal" href="#vsformat">VSFormat</a> *getFormatPreset(int id, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Returns a VSFormat structure from a video format identifier.</p>
<p>Thread-safe.</p>
<dl class="simple">
<dt><em>id</em></dt><dd><p>The format identifier: one of <a class="reference internal" href="#vspresetformat">VSPresetFormat</a> or a custom registered
format.</p>
</dd>
</dl>
<p>Returns NULL if the identifier is not known.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="registerformat">const <a class="reference internal" href="#vsformat">VSFormat</a> *registerFormat(int colorFamily, int sampleType, int bitsPerSample, int subSamplingW, int subSamplingH, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Registers a custom video format.</p>
<p>Thread-safe.</p>
<dl>
<dt><em>colorFamily</em></dt><dd><p>One of <a class="reference internal" href="#vscolorfamily">VSColorFamily</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Registering compat formats is not allowed. Only certain privileged
built-in filters are allowed to handle compat formats.</p>
</div>
</dd>
<dt><em>sampleType</em></dt><dd><p>One of <a class="reference internal" href="#vssampletype">VSSampleType</a>.</p>
</dd>
<dt><em>bitsPerSample</em></dt><dd><p>Number of meaningful bits for a single component. The valid range is
8-32.</p>
<p>For floating point formats, only 16 or 32 bits are allowed.</p>
</dd>
<dt><em>subSamplingW</em></dt><dd><p>log2 of the horizontal chroma subsampling. 0 == no subsampling.</p>
</dd>
<dt><em>subSamplingH</em></dt><dd><p>log2 of the vertical chroma subsampling. The valid range is 0-4.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RGB formats are not allowed to be subsampled in VapourSynth.</p>
</div>
</dd>
</dl>
<p>Returns a pointer to the created <a class="reference internal" href="#vsformat">VSFormat</a> object. Its <em>id</em> member
contains the attributed format identifier. The pointer is valid as long
as the <a class="reference internal" href="#vscore">VSCore</a> instance lives. Returns NULL in case an invalid format
is described.</p>
<p>If the parameters specify a format that is already registered (including
preset formats), then no new format is created and the existing one is
returned.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createmap"><a class="reference internal" href="#vsmap">VSMap</a> *createMap(void)</p>
<blockquote>
<div><p>Creates a new property map. It must be deallocated later with
<a class="reference internal" href="#freemap">freeMap</a>().</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="freemap">void freeMap(<a class="reference internal" href="#vsmap">VSMap</a> *map)</p>
<blockquote>
<div><p>Frees a map and all the objects it contains.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="clearmap">void clearMap(<a class="reference internal" href="#vsmap">VSMap</a> *map)</p>
<blockquote>
<div><p>Deletes all the keys and their associated values from the map, leaving it
empty.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="seterror">void setError(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *errorMessage)</p>
<blockquote>
<div><p>Adds an error message to a map. The map is cleared first. The error
message is copied. In this state the map may only be freed, cleared
or queried for the error message.</p>
<p>For errors encountered in a filter’s “getframe” function, use
<a class="reference internal" href="#setfiltererror">setFilterError</a>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="geterror">const char *getError(const <a class="reference internal" href="#vsmap">VSMap</a> *map)</p>
<blockquote>
<div><p>Returns a pointer to the error message contained in the map,
or NULL if there is no error message. The pointer is valid as long as
the map lives.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propnumkeys">int propNumKeys(const <a class="reference internal" href="#vsmap">VSMap</a> *map)</p>
<blockquote>
<div><p>Returns the number of keys contained in a property map.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgetkey">const char *propGetKey(const <a class="reference internal" href="#vsmap">VSMap</a> *map, int index)</p>
<blockquote>
<div><p>Returns a key from a property map.</p>
<p>Passing an invalid <em>index</em> will cause a fatal error.</p>
<p>The pointer is valid as long as the key exists in the map.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propdeletekey">int propDeleteKey(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key)</p>
<blockquote>
<div><p>Removes the property with the given key. All values associated with the
key are lost.</p>
<p>Returns 0 if the key isn’t in the map. Otherwise it returns 1.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgettype">char propGetType(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key)</p>
<blockquote>
<div><p>Returns the type of the elements associated with the given key in a
property map.</p>
<p>The returned value is one of <a class="reference internal" href="#vsproptypes">VSPropTypes</a>. If there is no such key in the
map, the returned value is ptUnset.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propnumelements">int propNumElements(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key)</p>
<blockquote>
<div><p>Returns the number of elements associated with a key in a property map.
Returns -1 if there is no such key in the map.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgetint">int64_t propGetInt(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves an integer from a map.</p>
<p>Returns the number on success, or 0 in case of error.</p>
<p>If the map has an error set (i.e. if <a class="reference internal" href="#geterror">getError</a>() returns non-NULL),
VapourSynth will die with a fatal error.</p>
<dl>
<dt><em>index</em></dt><dd><p>Zero-based index of the element.</p>
<p>Use <a class="reference internal" href="#propnumelements">propNumElements</a>() to know the total number of elements
associated with a key.</p>
</dd>
<dt><em>error</em></dt><dd><p>One of <a class="reference internal" href="#vsgetproperrors">VSGetPropErrors</a>, or 0 on success.</p>
<p>You may pass NULL here, but then any problems encountered while
retrieving the property will cause VapourSynth to die with a fatal
error.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgetintarray">const int64_t *propGetIntArray(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int *error)</p>
<blockquote>
<div><p>Retrieves an array of integers from a map. Use this function if there
are a lot of numbers associated with a key, because it is faster than
calling <a class="reference internal" href="#propgetint">propGetInt</a>() in a loop.</p>
<p>Returns a pointer to the first element of the array on success, or NULL
in case of error.</p>
<p>If the map has an error set (i.e. if <a class="reference internal" href="#geterror">getError</a>() returns non-NULL),
VapourSynth will die with a fatal error.</p>
<p>Use <a class="reference internal" href="#propnumelements">propNumElements</a>() to know the total number of elements associated
with a key.</p>
<dl>
<dt><em>error</em></dt><dd><p>One of <a class="reference internal" href="#vsgetproperrors">VSGetPropErrors</a>, or 0 on success.</p>
<p>You may pass NULL here, but then any problems encountered while
retrieving the property will cause VapourSynth to die with a fatal
error.</p>
</dd>
</dl>
<p>This function was introduced in API R3.1 (VapourSynth R26).</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgetfloat">double propGetFloat(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves a floating point number from a map.</p>
<p>Returns the number on success, or 0 in case of error.</p>
<p>If the map has an error set (i.e. if <a class="reference internal" href="#geterror">getError</a>() returns non-NULL),
VapourSynth will die with a fatal error.</p>
<dl>
<dt><em>index</em></dt><dd><p>Zero-based index of the element.</p>
<p>Use <a class="reference internal" href="#propnumelements">propNumElements</a>() to know the total number of elements
associated with a key.</p>
</dd>
<dt><em>error</em></dt><dd><p>One of <a class="reference internal" href="#vsgetproperrors">VSGetPropErrors</a>, or 0 on success.</p>
<p>You may pass NULL here, but then any problems encountered while
retrieving the property will cause VapourSynth to die with a fatal
error.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgetfloatarray">const double *propGetFloatArray(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int *error)</p>
<blockquote>
<div><p>Retrieves an array of floating point numbers from a map. Use this
function if there are a lot of numbers associated with a key, because
it is faster than calling <a class="reference internal" href="#propgetfloat">propGetFloat</a>() in a loop.</p>
<p>Returns a pointer to the first element of the array on success, or NULL
in case of error.</p>
<p>If the map has an error set (i.e. if <a class="reference internal" href="#geterror">getError</a>() returns non-NULL),
VapourSynth will die with a fatal error.</p>
<p>Use <a class="reference internal" href="#propnumelements">propNumElements</a>() to know the total number of elements associated
with a key.</p>
<dl>
<dt><em>error</em></dt><dd><p>One of <a class="reference internal" href="#vsgetproperrors">VSGetPropErrors</a>, or 0 on success.</p>
<p>You may pass NULL here, but then any problems encountered while
retrieving the property will cause VapourSynth to die with a fatal
error.</p>
</dd>
</dl>
<p>This function was introduced in API R3.1 (VapourSynth R26).</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgetdata">const char *propGetData(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves arbitrary binary data from a map.</p>
<p>Returns a pointer to the data on success, or NULL in case of error.</p>
<p>The array returned is guaranteed to be NULL-terminated. The NULL
byte is not considered to be part of the array (<a class="reference internal" href="#propgetdatasize">propGetDataSize</a>
doesn’t count it).</p>
<p>The pointer is valid until the map is destroyed, or until the
corresponding key is removed from the map or altered.</p>
<p>If the map has an error set (i.e. if <a class="reference internal" href="#geterror">getError</a>() returns non-NULL),
VapourSynth will die with a fatal error.</p>
<dl>
<dt><em>index</em></dt><dd><p>Zero-based index of the element.</p>
<p>Use <a class="reference internal" href="#propnumelements">propNumElements</a>() to know the total number of elements
associated with a key.</p>
</dd>
<dt><em>error</em></dt><dd><p>One of <a class="reference internal" href="#vsgetproperrors">VSGetPropErrors</a>, or 0 on success.</p>
<p>You may pass NULL here, but then any problems encountered while
retrieving the property will cause VapourSynth to die with a fatal
error.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgetdatasize">int propGetDataSize(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Returns the size in bytes of a property of type ptData (see
<a class="reference internal" href="#vsproptypes">VSPropTypes</a>), or 0 in case of error. The terminating NULL byte
added by <a class="reference internal" href="#propsetdata">propSetData</a>() is not counted.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgetnode"><a class="reference internal" href="#vsnoderef">VSNodeRef</a> *propGetNode(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves a node from a map.</p>
<p>Returns a pointer to the node on success, or NULL in case of error.</p>
<p>This function increases the node’s reference count, so <a class="reference internal" href="#freenode">freeNode</a>() must
be used when the node is no longer needed.</p>
<p>If the map has an error set (i.e. if <a class="reference internal" href="#geterror">getError</a>() returns non-NULL),
VapourSynth will die with a fatal error.</p>
<dl>
<dt><em>index</em></dt><dd><p>Zero-based index of the element.</p>
<p>Use <a class="reference internal" href="#propnumelements">propNumElements</a>() to know the total number of elements
associated with a key.</p>
</dd>
<dt><em>error</em></dt><dd><p>One of <a class="reference internal" href="#vsgetproperrors">VSGetPropErrors</a>, or 0 on success.</p>
<p>You may pass NULL here, but then any problems encountered while
retrieving the property will cause VapourSynth to die with a fatal
error.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgetframe">const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *propGetFrame(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves a frame from a map.</p>
<p>Returns a pointer to the frame on success, or NULL in case of error.</p>
<p>This function increases the frame’s reference count, so <a class="reference internal" href="#freeframe">freeFrame</a>() must
be used when the frame is no longer needed.</p>
<p>If the map has an error set (i.e. if <a class="reference internal" href="#geterror">getError</a>() returns non-NULL),
VapourSynth will die with a fatal error.</p>
<dl>
<dt><em>index</em></dt><dd><p>Zero-based index of the element.</p>
<p>Use <a class="reference internal" href="#propnumelements">propNumElements</a>() to know the total number of elements
associated with a key.</p>
</dd>
<dt><em>error</em></dt><dd><p>One of <a class="reference internal" href="#vsgetproperrors">VSGetPropErrors</a>, or 0 on success.</p>
<p>You may pass NULL here, but then any problems encountered while
retrieving the property will cause VapourSynth to die with a fatal
error.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propgetfunc"><a class="reference internal" href="#vsfuncref">VSFuncRef</a> *propGetFunc(const <a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int index, int *error)</p>
<blockquote>
<div><p>Retrieves a function from a map.</p>
<p>Returns a pointer to the function on success, or NULL in case of error.</p>
<p>This function increases the function’s reference count, so <a class="reference internal" href="#freefunc">freeFunc</a>() must
be used when the function is no longer needed.</p>
<p>If the map has an error set (i.e. if <a class="reference internal" href="#geterror">getError</a>() returns non-NULL),
VapourSynth will die with a fatal error.</p>
<dl>
<dt><em>index</em></dt><dd><p>Zero-based index of the element.</p>
<p>Use <a class="reference internal" href="#propnumelements">propNumElements</a>() to know the total number of elements associated
with a key.</p>
</dd>
<dt><em>error</em></dt><dd><p>One of <a class="reference internal" href="#vsgetproperrors">VSGetPropErrors</a>, or 0 on success.</p>
<p>You may pass NULL here, but then any problems encountered while
retrieving the property will cause VapourSynth to die with a fatal
error.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propsetint">int propSetInt(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, int64_t i, int append)</p>
<blockquote>
<div><p>Adds a property to a map.</p>
<p>Multiple values can be associated with one key, but they must all be the
same type.</p>
<dl class="simple">
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and the underscore
may be used.</p>
</dd>
<dt><em>i</em></dt><dd><p>Value to store.</p>
</dd>
<dt><em>append</em></dt><dd><p>One of <a class="reference internal" href="#vspropappendmode">VSPropAppendMode</a>.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if trying to append to a property with the
wrong type.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propsetintarray">int propSetIntArray(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, const int64_t *i, int size)</p>
<blockquote>
<div><p>Adds an array of integers to a map. Use this function if there are a
lot of numbers to add, because it is faster than calling <a class="reference internal" href="#propsetint">propSetInt</a>()
in a loop.</p>
<p>If <em>map</em> already contains a property with this <em>key</em>, that property will
be overwritten and all old values will be lost.</p>
<dl class="simple">
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and the underscore
may be used.</p>
</dd>
<dt><em>i</em></dt><dd><p>Pointer to the first element of the array to store.</p>
</dd>
<dt><em>size</em></dt><dd><p>Number of integers to read from the array. It can be 0, in which case
no integers are read from the array, and the property will be created
empty.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if <em>size</em> is negative.</p>
<p>This function was introduced in API R3.1 (VapourSynth R26).</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propsetfloat">int propSetFloat(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, double d, int append)</p>
<blockquote>
<div><p>Adds a property to a map.</p>
<p>Multiple values can be associated with one key, but they must all be the
same type.</p>
<dl class="simple">
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and the underscore
may be used.</p>
</dd>
<dt><em>d</em></dt><dd><p>Value to store.</p>
</dd>
<dt><em>append</em></dt><dd><p>One of <a class="reference internal" href="#vspropappendmode">VSPropAppendMode</a>.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if trying to append to a property with the
wrong type.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propsetfloatarray">int propSetFloatArray(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, const double *d, int size)</p>
<blockquote>
<div><p>Adds an array of floating point numbers to a map. Use this function if
there are a lot of numbers to add, because it is faster than calling
<a class="reference internal" href="#propsetfloat">propSetFloat</a>() in a loop.</p>
<p>If <em>map</em> already contains a property with this <em>key</em>, that property will
be overwritten and all old values will be lost.</p>
<dl class="simple">
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and the underscore
may be used.</p>
</dd>
<dt><em>d</em></dt><dd><p>Pointer to the first element of the array to store.</p>
</dd>
<dt><em>size</em></dt><dd><p>Number of floating point numbers to read from the array. It can be 0,
in which case no numbers are read from the array, and the property
will be created empty.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if <em>size</em> is negative.</p>
<p>This function was introduced in API R3.1 (VapourSynth R26).</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propsetdata">int propSetData(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, const char *data, int size, int append)</p>
<blockquote>
<div><p>Adds a property to a map.</p>
<p>Multiple values can be associated with one key, but they must all be the
same type.</p>
<dl>
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and the underscore
may be used.</p>
</dd>
<dt><em>data</em></dt><dd><p>Value to store.</p>
<p>This function copies the data, so the pointer should be freed when
no longer needed.</p>
</dd>
<dt><em>size</em></dt><dd><p>The number of bytes to copy. If this is negative, everything up to
the first NULL byte will be copied.</p>
<p>This function will always add a NULL byte at the end of the data.</p>
</dd>
<dt><em>append</em></dt><dd><p>One of <a class="reference internal" href="#vspropappendmode">VSPropAppendMode</a>.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if trying to append to a property with the
wrong type.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propsetnode">int propSetNode(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, <a class="reference internal" href="#vsnoderef">VSNodeRef</a> *node, int append)</p>
<blockquote>
<div><p>Adds a property to a map.</p>
<p>Multiple values can be associated with one key, but they must all be the
same type.</p>
<dl>
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and the underscore
may be used.</p>
</dd>
<dt><em>node</em></dt><dd><p>Value to store.</p>
<p>This function will increase the node’s reference count, so the
pointer should be freed when no longer needed.</p>
</dd>
<dt><em>append</em></dt><dd><p>One of <a class="reference internal" href="#vspropappendmode">VSPropAppendMode</a>.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if trying to append to a property with the
wrong type.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propsetframe">int propSetFrame(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *f, int append)</p>
<blockquote>
<div><p>Adds a property to a map.</p>
<p>Multiple values can be associated with one key, but they must all be the
same type.</p>
<dl>
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and the underscore
may be used.</p>
</dd>
<dt><em>f</em></dt><dd><p>Value to store.</p>
<p>This function will increase the frame’s reference count, so the
pointer should be freed when no longer needed.</p>
</dd>
<dt><em>append</em></dt><dd><p>One of <a class="reference internal" href="#vspropappendmode">VSPropAppendMode</a>.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if trying to append to a property with the
wrong type.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="propsetfunc">int propSetFunc(<a class="reference internal" href="#vsmap">VSMap</a> *map, const char *key, <a class="reference internal" href="#vsfuncref">VSFuncRef</a> *func, int append)</p>
<blockquote>
<div><p>Adds a property to a map.</p>
<p>Multiple values can be associated with one key, but they must all be the
same type.</p>
<dl>
<dt><em>key</em></dt><dd><p>Name of the property. Alphanumeric characters and the underscore
may be used.</p>
</dd>
<dt><em>func</em></dt><dd><p>Value to store.</p>
<p>This function will increase the function’s reference count, so the
pointer should be freed when no longer needed.</p>
</dd>
<dt><em>append</em></dt><dd><p>One of <a class="reference internal" href="#vspropappendmode">VSPropAppendMode</a>.</p>
</dd>
</dl>
<p>Returns 0 on success, or 1 if trying to append to a property with the
wrong type.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginbyid"><a class="reference internal" href="#vsplugin">VSPlugin</a> *getPluginById(const char *identifier, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Returns a pointer to the plugin with the given identifier, or NULL
if not found.</p>
<dl class="simple">
<dt><em>identifier</em></dt><dd><p>Reverse URL that uniquely identifies the plugin.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginbyns"><a class="reference internal" href="#vsplugin">VSPlugin</a> *getPluginByNs(const char *ns, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Returns a pointer to the plugin with the given namespace, or NULL
if not found.</p>
<p><a class="reference internal" href="#getpluginbyid">getPluginById</a> should be used instead.</p>
<dl class="simple">
<dt><em>ns</em></dt><dd><p>Namespace.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getplugins"><a class="reference internal" href="#vsmap">VSMap</a> *getPlugins(<a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Returns a map containing a list of all loaded plugins. The map
must be freed when no longer needed.</p>
<dl class="simple">
<dt>Keys:</dt><dd><p>Meaningless unique strings.</p>
</dd>
<dt>Values:</dt><dd><p>Namespace, identifier, and full name, separated by semicolons.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getfunctions"><a class="reference internal" href="#vsmap">VSMap</a> *getFunctions(<a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>Returns a map containing a list of the filters exported by a plugin.
The map must be freed when no longer needed.</p>
<dl class="simple">
<dt>Keys:</dt><dd><p>The filter names.</p>
</dd>
<dt>Values:</dt><dd><p>The filter name followed by its argument string, separated by a semicolon.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getpluginpath">const char *getPluginPath(const <a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>Returns the absolute path to the plugin, including the plugin’s file
name. This is the real location of the plugin, i.e. there are no
symbolic links in the path.</p>
<p>Path elements are always delimited with forward slashes.</p>
<p>VapourSynth retains ownership of the returned pointer.</p>
<p>This function was introduced in VapourSynth R25 without bumping
the API version (R3).</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createfunc"><a class="reference internal" href="#vsfuncref">VSFuncRef</a> *createFunc(VSPublicFunction func, void *userData, VSFreeFuncData free, VSCore *core, const VSAPI *vsapi)</p>
<blockquote>
<div><dl>
<dt><em>func</em></dt><dd><p>typedef void (VS_CC *VSPublicFunction)(const <a class="reference internal" href="#vsmap">VSMap</a> *in, <a class="reference internal" href="#vsmap">VSMap</a> *out, void *userData, <a class="reference internal" href="#vscore">VSCore</a> *core, const <a class="reference internal" href="#vsapi">VSAPI</a> *vsapi)</p>
<p>User-defined function that may be called in any context.</p>
</dd>
<dt><em>userData</em></dt><dd><p>Pointer passed to <em>func</em>.</p>
</dd>
<dt><em>free</em></dt><dd><p>typedef void (VS_CC *VSFreeFuncData)(void *userData)</p>
<p>Callback tasked with freeing <em>userData</em>.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="clonefuncref"><a class="reference internal" href="#vsfuncref">VSFuncRef</a> *cloneFuncRef(<a class="reference internal" href="#vsfuncref">VSFuncRef</a> *f)</p>
<blockquote>
<div><p>Duplicates a func reference. This new reference has to be deleted with
<a class="reference internal" href="#freefunc">freeFunc</a>() when it is no longer needed.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="callfunc">void callFunc(<a class="reference internal" href="#vsfuncref">VSFuncRef</a> *func, const <a class="reference internal" href="#vsmap">VSMap</a> *in, <a class="reference internal" href="#vsmap">VSMap</a> *out, <a class="reference internal" href="#vscore">VSCore</a> *core, const <a class="reference internal" href="#vsapi">VSAPI</a> *vsapi)</p>
<blockquote>
<div><p>Calls a function. If the call fails <em>out</em> will have an error set.</p>
<dl class="simple">
<dt><em>func</em></dt><dd><p>Function to be called.</p>
</dd>
<dt><em>in</em></dt><dd><p>Arguments passed to <em>func</em>.</p>
</dd>
<dt><em>out</em></dt><dd><p>Returned values from <em>func</em>.</p>
</dd>
<dt><em>core</em></dt><dd><p>Must be NULL.</p>
</dd>
<dt><em>vsapi</em></dt><dd><p>Must be NULL.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="freefunc">void freeFunc(<a class="reference internal" href="#vsfuncref">VSFuncRef</a> *f)</p>
<blockquote>
<div><p>Deletes a function reference, releasing the caller’s ownership of the function.</p>
<p>It is safe to pass NULL.</p>
<p>Don’t try to use the function once the reference has been deleted.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="createfilter">void createFilter(const <a class="reference internal" href="#vsmap">VSMap</a> *in, <a class="reference internal" href="#vsmap">VSMap</a> *out, const char *name, <a class="reference internal" href="#vsfilterinit">VSFilterInit</a> init, <a class="reference internal" href="#vsfiltergetframe">VSFilterGetFrame</a> getFrame, <a class="reference internal" href="#vsfilterfree">VSFilterFree</a> free, int filterMode, int flags, void *instanceData, <a class="reference internal" href="#vscore">VSCore</a> *core)</p>
<blockquote>
<div><p>Creates a new filter node.</p>
<dl class="simple">
<dt><em>in</em></dt><dd><p>List of the filter’s arguments.</p>
</dd>
<dt><em>out</em></dt><dd><p>List of the filter’s return values (clip(s) or an error).</p>
</dd>
<dt><em>name</em></dt><dd><p>Instance name. Please make it the same as the filter’s name.</p>
</dd>
<dt><em>init</em></dt><dd><p>The filter’s “init” function. Must not be NULL.</p>
</dd>
<dt><em>getFrame</em></dt><dd><p>The filter’s “getframe” function. Must not be NULL.</p>
</dd>
<dt><em>free</em></dt><dd><p>The filter’s “free” function. Can be NULL.</p>
</dd>
<dt><em>filterMode</em></dt><dd><p>One of <a class="reference internal" href="#vsfiltermode">VSFilterMode</a>. Indicates the level of parallelism
supported by the filter.</p>
</dd>
<dt><em>flags</em></dt><dd><p>Set to nfNoCache (<a class="reference internal" href="#vsnodeflags">VSNodeFlags</a>) if the frames generated by the filter
should not be cached. It is useful for filters that only shuffle
frames around without modifying them (e.g. std.Interleave). For most
filters this should be 0.</p>
</dd>
<dt><em>instanceData</em></dt><dd><p>A pointer to the private filter data. This pointer will be passed to
the <em>init</em>, <em>getFrame</em>, and <em>free</em> functions. It should be freed by
the <em>free</em> function.</p>
</dd>
</dl>
<p>After this function returns, <em>out</em> will contain the new node(s) in the
“clip” property, or an error, if something went wrong.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="registerfunction">void registerFunction(const char *name, const char *args, VSPublicFunction argsFunc, void *functionData, <a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>See <a class="reference internal" href="#vsinitplugin">VSInitPlugin</a>.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="invoke"><a class="reference internal" href="#vsmap">VSMap</a> *invoke(<a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin, const char *name, const <a class="reference internal" href="#vsmap">VSMap</a> *args)</p>
<blockquote>
<div><p>Invokes a filter.</p>
<p>invoke() makes sure the filter has no compat input nodes, checks that
the <em>args</em> passed to the filter are consistent with the argument list
registered by the plugin that contains the filter, calls the filter’s
“create” function, and checks that the filter doesn’t return any compat
nodes. If everything goes smoothly, the filter will be ready to generate
frames after invoke() returns.</p>
<p>Thread-safe.</p>
<dl>
<dt><em>plugin</em></dt><dd><p>A pointer to the plugin where the filter is located. Must not be NULL.</p>
<p>See <a class="reference internal" href="#getpluginbyid">getPluginById</a>() and <a class="reference internal" href="#getpluginbyns">getPluginByNs</a>().</p>
</dd>
<dt><em>name</em></dt><dd><p>Name of the filter to invoke.</p>
</dd>
<dt><em>args</em></dt><dd><p>Arguments for the filter.</p>
</dd>
</dl>
<p>Returns a map containing the filter’s return value(s). The caller gets
ownership of the map. Use <a class="reference internal" href="#geterror">getError</a>() to check if the filter was invoked
successfully.</p>
<p>Most filters will either add an error to the map, or one or more clips
with the key “clip”. The exception to this are functions, for example
LoadPlugin, which doesn’t return any clips for obvious reasons.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="setfiltererror">void setFilterError(const char *errorMessage, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><p>Adds an error message to a frame context, replacing the existing message,
if any.</p>
<p>This is the way to report errors in a filter’s “getframe” function.
Such errors are not necessarily fatal, i.e. the caller can try to
request the same frame again.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="getoutputindex">int getOutputIndex(<a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><p>Returns the index of the node from which the frame is being requested.</p>
<p>Only needed in the “getframe” function of filters that return more than
one clip.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="querycompletedframe">void queryCompletedFrame(<a class="reference internal" href="#vsnoderef">VSNodeRef</a> **node, int *n, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function has several issues and may or may not return the
actual node or frame number.</p>
</div>
<p>Finds out which requested frame is ready. To be used in a filter’s
“getframe” function, when it is called with <em>activationReason</em>
arFrameReady.</p>
</div></blockquote>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p id="releaseframeearly">void releaseFrameEarly(<a class="reference internal" href="#vsnoderef">VSNodeRef</a> *node, int n, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx)</p>
<blockquote>
<div><p>Normally a reference is kept to all requested frames until the current frame is complete.
If a filter scans a large number of frames this can consume all memory, instead the filter
should release the internal frame references as well immediately by calling this function.</p>
<p>Only use inside a filter’s “getframe” function.</p>
</div></blockquote>
</div></blockquote>
</section>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline"></a></h2>
<p id="getvapoursynthapi">const <a class="reference internal" href="#vsapi">VSAPI</a>* getVapourSynthAPI(int version)</p>
<blockquote>
<div><p>Returns a pointer to the global VSAPI instance.</p>
<p>Returns NULL if the requested API version is not supported or if the system
does not meet the minimum requirements to run VapourSynth.</p>
</div></blockquote>
</section>
<section id="writing-plugins">
<h2>Writing plugins<a class="headerlink" href="#writing-plugins" title="Permalink to this headline"></a></h2>
<p>A simple VapourSynth plugin which exports one filter will contain five
functions: an entry point (called <code class="docutils literal notranslate"><span class="pre">VapourSynthPluginInit</span></code>), a function tasked
with creating a filter instance (often called <code class="docutils literal notranslate"><span class="pre">fooCreate</span></code>), an “init” function
(often called <code class="docutils literal notranslate"><span class="pre">fooInit</span></code>), a “getframe” function (often called <code class="docutils literal notranslate"><span class="pre">fooGetframe</span></code>),
and a “free” function (often called <code class="docutils literal notranslate"><span class="pre">fooFree</span></code>). These functions are described
below.</p>
<p>Another thing a filter requires is an object for storing a filter instance’s
private data. This object will usually contain the filter’s input nodes (if it
has any) and a <a class="reference internal" href="#vsvideoinfo">VSVideoInfo</a> struct describing the video the filter wants to
return.</p>
<p>The <a class="reference external" href="https://github.com/vapoursynth/vapoursynth/tree/master/sdk">sdk</a> folder
in the VapourSynth source contains some examples.</p>
<hr class="docutils" />
<p id="vsinitplugin">typedef void (VS_CC *VSInitPlugin)(VSConfigPlugin configFunc, VSRegisterFunction registerFunc, <a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<blockquote>
<div><p>A plugin’s entry point. It must be called <code class="docutils literal notranslate"><span class="pre">VapourSynthPluginInit</span></code>.
This function is called after the core loads the shared library. Its purpose
is to configure the plugin and to register the filters the plugin wants to
export.</p>
<dl>
<dt><em>configFunc</em></dt><dd><p>typedef void (VS_CC *VSConfigPlugin)(const char *identifier, const char *defaultNamespace, const char *name, int apiVersion, int readonly, <a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<p>Configures the plugin. Call <strong>once</strong>, before calling <em>registerFunc</em>.</p>
<dl>
<dt><em>identifier</em></dt><dd><p>Reverse URL that must uniquely identify the plugin.</p>
<p>If you don’t own a domain then make one up that’s related to the
plugin name.</p>
<p>Example: “com.vapoursynth.std”</p>
</dd>
<dt><em>defaultNamespace</em></dt><dd><p>Namespace where the plugin’s filters will go. This, too, must be
unique.</p>
<p>Only lowercase letters and the underscore should be used, and it
shouldn’t be too long. Additionally, words that are special to
Python, e.g. “del”, should be avoided.</p>
<p>Example: “resize”</p>
</dd>
<dt><em>name</em></dt><dd><p>Plugin name in readable form.</p>
</dd>
<dt><em>apiVersion</em></dt><dd><p>The VapourSynth API version the plugin uses.</p>
<p>Use the <a class="reference internal" href="#vapoursynth-api-version">VAPOURSYNTH_API_VERSION</a> macro.</p>
</dd>
<dt><em>readonly</em></dt><dd><p>If set to 0, the plugin can export new filters after initialisation.
The built-in Avisynth compat plugin uses this feature to add filters
at runtime, as they are loaded. Most plugins should set this to 1.</p>
</dd>
<dt><em>plugin</em></dt><dd><p>Pointer to the plugin object in the core, as passed to
VapourSynthPluginInit().</p>
</dd>
</dl>
</dd>
<dt><em>registerFunc</em></dt><dd><p>typedef void (VS_CC *VSRegisterFunction)(const char *name, const char *args, VSPublicFunction argsFunc, void *functionData, <a class="reference internal" href="#vsplugin">VSPlugin</a> *plugin)</p>
<p>Function that registers a filter exported by the plugin. A plugin can
export any number of filters.</p>
<dl>
<dt><em>name</em></dt><dd><p>Filter name. The characters allowed are letters, numbers, and the
underscore. The first character must be a letter. In other words:
<code class="docutils literal notranslate"><span class="pre">^[a-zA-Z][a-zA-Z0-9_]*$</span></code></p>
<p>Filter names <em>should be</em> PascalCase.</p>
</dd>
<dt><em>args</em></dt><dd><p>String containing the filter’s list of arguments.</p>
<p>Arguments are separated by a semicolon. Each argument is made of
several fields separated by a colon. Don’t insert additional
whitespace characters, or VapourSynth will die.</p>
<dl>
<dt>Fields:</dt><dd><dl>
<dt>The argument name.</dt><dd><p>The same characters are allowed as for the filter’s name.
Argument names <em>should be</em> all lowercase and use only letters
and the underscore.</p>
</dd>
<dt>The type.</dt><dd><p>“int”: int64_t</p>
<p>“float”: double</p>
<p>“data”: const char*</p>
<p>“clip”: const <a class="reference internal" href="#vsnoderef">VSNodeRef</a>*</p>
<p>“frame”: const <a class="reference internal" href="#vsframeref">VSFrameRef</a>*</p>
<p>“func”: const <a class="reference internal" href="#vsfuncref">VSFuncRef</a>*</p>
<p>It is possible to declare an array by appending “[]” to the type.</p>
</dd>
<dt>“opt”</dt><dd><p>If the parameter is optional.</p>
</dd>
<dt>“empty”</dt><dd><p>For arrays that are allowed to be empty.</p>
</dd>
</dl>
</dd>
</dl>
<p>The following example declares the arguments “blah”, “moo”, and “asdf”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">blah</span><span class="p">:</span><span class="n">clip</span><span class="p">;</span><span class="n">moo</span><span class="p">:</span><span class="nb">int</span><span class="p">[]:</span><span class="n">opt</span><span class="p">;</span><span class="n">asdf</span><span class="p">:</span><span class="nb">float</span><span class="p">:</span><span class="n">opt</span><span class="p">;</span>
</pre></div>
</div>
</dd>
<dt><em>argsFunc</em></dt><dd><p>typedef void (VS_CC *VSPublicFunction)(const <a class="reference internal" href="#vsmap">VSMap</a> *in, <a class="reference internal" href="#vsmap">VSMap</a> *out, void *userData, <a class="reference internal" href="#vscore">VSCore</a> *core, const <a class="reference internal" href="#vsapi">VSAPI</a> *vsapi)</p>
<p>User-defined function called by the core to create an instance of the
filter. This function is often named <code class="docutils literal notranslate"><span class="pre">fooCreate</span></code>.</p>
<p>In this function, the filter’s input parameters should be retrieved
and validated, the filter’s private instance data should be
initialised, and <a class="reference internal" href="#createfilter">createFilter</a>() should be called. This is where
the filter should perform any other initialisation it requires.</p>
<p>If for some reason you cannot create the filter, you have to free any
created node references using <a class="reference internal" href="#freenode">freeNode</a>(), call <a class="reference internal" href="#seterror">setError</a>() on
<em>out</em>, and return.</p>
<dl>
<dt><em>in</em></dt><dd><p>Input parameter list.</p>
<p>Use <a class="reference internal" href="#propgetint">propGetInt</a>() and friends to retrieve a parameter value.</p>
<p>The map is guaranteed to exist only until the filter’s “init”
function returns. In other words, pointers returned by
<a class="reference internal" href="#propgetdata">propGetData</a>() will not be usable in the filter’s “getframe” and
“free” functions.</p>
</dd>
<dt><em>out</em></dt><dd><p>Output parameter list. <a class="reference internal" href="#createfilter">createFilter</a>() will add the output
node(s) with the key named “clip”, or an error, if something went
wrong.</p>
</dd>
<dt><em>userData</em></dt><dd><p>Pointer that was passed to <a class="reference internal" href="#registerfunction">registerFunction</a>().</p>
</dd>
</dl>
</dd>
<dt><em>functionData</em></dt><dd><p>Pointer to user data that gets passed to <em>argsFunc</em> when creating a
filter. Useful to register multiple filters using a single <em>argsFunc</em>
function.</p>
</dd>
<dt><em>plugin</em></dt><dd><p>Pointer to the plugin object in the core, as passed to
VapourSynthPluginInit().</p>
</dd>
</dl>
</dd>
<dt><em>plugin</em></dt><dd><p>The plugin object in the core. Pass to <em>configFunc</em> and <em>registerFunc</em>.</p>
</dd>
</dl>
</div></blockquote>
<hr class="docutils" />
<p id="vsfilterinit">typedef void (VS_CC *VSFilterInit)(<a class="reference internal" href="#vsmap">VSMap</a> *in, <a class="reference internal" href="#vsmap">VSMap</a> *out, void **instanceData, <a class="reference internal" href="#vsnode">VSNode</a> *node, <a class="reference internal" href="#vscore">VSCore</a> *core, const <a class="reference internal" href="#vsapi">VSAPI</a> *vsapi)</p>
<blockquote>
<div><p>A filter’s “init” function.</p>
<p>This function is called by <a class="reference internal" href="#createfilter">createFilter</a>() (indirectly).</p>
<p>This is the only place where <a class="reference internal" href="#setvideoinfo">setVideoInfo</a>() can be called. There is no
reason to do anything else here.</p>
<dl class="simple">
<dt>If an error occurs in this function:</dt><dd><ul class="simple">
<li><p>free the input nodes, if any</p></li>
<li><p>free the instance data</p></li>
<li><p>free whatever else got allocated so far (obviously)</p></li>
<li><p>call <a class="reference internal" href="#seterror">setError</a>() on the <em>out</em> map</p></li>
<li><p>return</p></li>
</ul>
</dd>
<dt><em>instanceData</em></dt><dd><p>Pointer to a pointer to the filter’s private instance data.</p>
</dd>
</dl>
</div></blockquote>
<hr class="docutils" />
<p id="vsfiltergetframe">typedef const <a class="reference internal" href="#vsframeref">VSFrameRef</a> *(VS_CC *VSFilterGetFrame)(int n, int activationReason, void **instanceData, void **frameData, <a class="reference internal" href="#vsframecontext">VSFrameContext</a> *frameCtx, <a class="reference internal" href="#vscore">VSCore</a> *core, const <a class="reference internal" href="#vsapi">VSAPI</a> *vsapi)</p>
<blockquote>
<div><p>A filter’s “getframe” function. It is called by the core when it needs
the filter to generate a frame.</p>
<p>It is possible to allocate local data, persistent during the multiple
calls requesting the output frame.</p>
<p>In case of error, call <a class="reference internal" href="#setfiltererror">setFilterError</a>(), free *frameData if required,
and return NULL.</p>
<p>Depending on the <a class="reference internal" href="#vsfiltermode">VSFilterMode</a> set for the filter, multiple output frames
could be requested concurrently.</p>
<p>It is never called concurrently for the same frame number.</p>
<dl>
<dt><em>n</em></dt><dd><p>Requested frame number.</p>
</dd>
<dt><em>activationReason</em></dt><dd><p>One of <a class="reference internal" href="#vsactivationreason">VSActivationReason</a>.</p>
<p>This function is first called with <em>activationReason</em> arInitial. At this
point the function should request the input frames it needs and return
NULL. When one or all of the requested frames are ready, this function
is called again with <em>activationReason</em> arFrameReady or arAllFramesReady.
The function should only return a frame when called with
<em>activationReason</em> arAllFramesReady.</p>
<p>In the case of arFrameReady, use <a class="reference internal" href="#querycompletedframe">queryCompletedFrame</a>() to find out
which of the requested frames is ready.</p>
<p>Most filters will only need to handle arInitial and arAllFramesReady.</p>
</dd>
<dt><em>instanceData</em></dt><dd><p>The filter’s private instance data.</p>
</dd>
<dt><em>frameData</em></dt><dd><p>Optional private data associated with output frame number <em>n</em>.
It must be deallocated before the last call for the given frame
(arAllFramesReady or error).</p>
<p>By default, <em>frameData</em> is a pointer to NULL.</p>
</dd>
</dl>
<p>Return a reference to the output frame number <em>n</em> when it is ready, or NULL.
The ownership of the frame is transferred to the caller.</p>
</div></blockquote>
<hr class="docutils" />
<p id="vsfilterfree">typedef void (VS_CC *VSFilterFree)(void *instanceData, <a class="reference internal" href="#vscore">VSCore</a> *core, const <a class="reference internal" href="#vsapi">VSAPI</a> *vsapi)</p>
<blockquote>
<div><p>A filter’s “free” function.</p>
<p>This is where the filter should free everything it allocated,
including its instance data.</p>
<dl class="simple">
<dt><em>instanceData</em></dt><dd><p>The filter’s private instance data.</p>
</dd>
</dl>
</div></blockquote>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../apireference.html" class="btn btn-neutral float-left" title="VapourSynth C API Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="vshelper.h.html" class="btn btn-neutral float-right" title="VSHelper.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2012-2022, Fredrik Mellbin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>