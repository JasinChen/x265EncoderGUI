

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>SimpleMmxOptimization &#8212; AviSynth+ 3.4 documentation</title>
    <link rel="stylesheet" href="../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/bizstyle.js"></script>
    <link rel="shortcut icon" href="../../_static/AvsiDoc.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="SimpleSample" href="SimpleSample.html" />
    <link rel="prev" title="SDKNecessaries" href="SDKNecessaries.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="SimpleSample.html" title="SimpleSample"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="SDKNecessaries.html" title="SDKNecessaries"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">AviSynth+ 3.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Invisible Tree</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/DocIcon-Large.svg" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="SDKNecessaries.html"
                        title="previous chapter">SDKNecessaries</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="SimpleSample.html"
                        title="next chapter">SimpleSample</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/avisynthdoc/FilterSDK/SimpleMmxOptimization.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="simplemmxoptimization">
<h1>SimpleMmxOptimization<a class="headerlink" href="#simplemmxoptimization" title="Permalink to this headline">¶</a></h1>
<p>This will cover some basics in assembler optimization, and the syntax to use
in Visual Studio C++ for inline assembler.</p>
<p>This will cover a basic routine in C++, and how it is converted to MMX. The
example is from an actual filter in AviSynth, with only minor changes.</p>
<p>Consider the following C-routing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Limiter</span><span class="p">::</span><span class="n">c_limiter</span><span class="p">(</span><span class="n">BYTE</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">row_size</span><span class="p">,</span> <span class="nb">int</span> <span class="n">height</span><span class="p">,</span> <span class="nb">int</span> <span class="n">modulo</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cmin</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cmax</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">for</span><span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">row_size</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cmin</span><span class="p">)</span>
                <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmin</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cmax</span><span class="p">)</span>
                <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmax</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">p</span> <span class="o">+=</span> <span class="n">row_size</span><span class="o">+</span><span class="n">modulo</span><span class="p">;</span>

        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>The parameters of this routine is:</p>
<ul class="simple">
<li><em>p</em> - a pointer to the information being processed.</li>
<li><em>row_size</em> - the width of a row in bytes.</li>
<li><em>height</em> - the height of the image in bytes.</li>
<li><em>modulo</em> - the difference between the pitch and the rowsize (pitch -
rowsize).</li>
<li><em>cmin, cmax</em> - the maximum and minimum values of a pixel.</li>
</ul>
<p>When converting to <a class="reference internal" href="MMX.html"><span class="doc">MMX</span></a> and <a class="reference internal" href="IntegerSSE.html"><span class="doc">IntegerSSE</span></a> it is a good thing to look at
which commands are available for the task needed. In this case we choose to
focus on <a class="reference internal" href="IntegerSSE.html"><span class="doc">IntegerSSE</span></a>, because it contains pminub and pmaxub, which selects
the minimum and maximum bytes of two packed registers. It is always a good
idea to support plain MMX, since there are still many machines out there,
that only support these instructions.</p>
<p>An important aspect of MMX is parallel processing. That means processing
several bytes at once. The MMX instructions all work on 8 bytes at the time,
but in many cases, you have to unpack these bytes to words (8 to 16 bits) to
be able to do things like additions, etc.)</p>
<p>The equivalent of the routine above in <a class="reference internal" href="IntegerSSE.html"><span class="doc">IntegerSSE</span></a> looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Limiter</span><span class="p">::</span><span class="n">isse_limiter_mod8</span><span class="p">(</span><span class="n">BYTE</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">row_size</span><span class="p">,</span> <span class="nb">int</span> <span class="n">height</span><span class="p">,</span> <span class="nb">int</span> <span class="n">modulo</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cmin</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cmax</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">cmax</span><span class="o">|=</span><span class="p">(</span><span class="n">cmax</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">);</span>

    <span class="n">cmin</span><span class="o">|=</span><span class="p">(</span><span class="n">cmin</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">);</span>

    <span class="n">__asm</span> <span class="p">{</span>
        <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">height</span><span class="p">]</span>
        <span class="n">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">p</span>
        <span class="n">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="p">[</span><span class="n">modulo</span><span class="p">]</span>
        <span class="n">movd</span> <span class="n">mm7</span><span class="p">,[</span><span class="n">cmax</span><span class="p">]</span>
        <span class="n">movd</span> <span class="n">mm6</span><span class="p">,[</span><span class="n">cmin</span><span class="p">]</span>
        <span class="n">pshufw</span> <span class="n">mm7</span><span class="p">,</span><span class="n">mm7</span><span class="p">,</span><span class="mi">0</span>
        <span class="n">pshufw</span> <span class="n">mm6</span><span class="p">,</span><span class="n">mm6</span><span class="p">,</span><span class="mi">0</span>

        <span class="n">yloop</span><span class="p">:</span>
        <span class="n">mov</span> <span class="n">edx</span><span class="p">,[</span><span class="n">row_size</span><span class="p">]</span>

        <span class="n">align</span> <span class="mi">16</span>
        <span class="n">xloop</span><span class="p">:</span>
        <span class="n">movq</span> <span class="n">mm0</span><span class="p">,[</span><span class="n">ebx</span><span class="p">]</span>
        <span class="n">pminub</span> <span class="n">mm0</span><span class="p">,</span><span class="n">mm7</span>
        <span class="n">pmaxub</span> <span class="n">mm0</span><span class="p">,</span><span class="n">mm6</span>
        <span class="n">movq</span> <span class="p">[</span><span class="n">ebx</span><span class="p">],</span><span class="n">mm0</span>
        <span class="n">add</span> <span class="n">ebx</span><span class="p">,</span><span class="mi">8</span>
        <span class="n">sub</span> <span class="n">edx</span><span class="p">,</span><span class="mi">8</span>
        <span class="n">jnz</span> <span class="n">xloop</span>
        <span class="n">add</span> <span class="n">ebx</span><span class="p">,</span><span class="n">ecx</span><span class="p">;</span>
        <span class="n">dec</span> <span class="n">eax</span>
        <span class="n">jnz</span> <span class="n">yloop</span>
        <span class="n">emms</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This routine performs the same task as the routine above. The filter requires
mod8 rowsize, because it processes 8 pixels in parallel.</p>
<p>Let’s go through the code, line by line.</p>
<p><code class="docutils literal notranslate"><span class="pre">cmax|=(cmax&lt;&lt;8);</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">cmin|=(cmin&lt;&lt;8);</span></code></p>
<p>This is code is plain C,
and can be seen as preparation for the assembler. Writing the same code is of
course possible in assembler, but there is no speed gain at all, since this
is only used once.</p>
<p><code class="docutils literal notranslate"><span class="pre">__asm</span> <span class="pre">{</span></code></p>
<p>This shows MSVC, that an assembler block
is coming. When you enter an assembler block you have to assume that all your
registers contain garbage. There are 6 general purpose 32-bit registers, that
can be used freely within the assembler block, these are <em>eax, ebx, ecx, edx,
esi</em> and <em>edi</em>.</p>
<p><code class="docutils literal notranslate"><span class="pre">mov</span> <span class="pre">eax,</span> <span class="pre">[height]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">mov</span> <span class="pre">ebx,</span> <span class="pre">p</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">mov</span> <span class="pre">ecx,</span> <span class="pre">[modulo]</span></code></p>
<p>In these lines we put data into the registers. eax contains the
height, ebx contains a pointer to the plane we are processing, ecx contains
the modulo information. Note that the destination is always written FIRST. So
the first line translates to “move height into eax”.</p>
<p><code class="docutils literal notranslate"><span class="pre">movd</span> <span class="pre">mm7,[cmax]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">movd</span> <span class="pre">mm6,[cmin]</span></code></p>
<p>These two lines move data into the mmx registers - there are 8 mmx registers, named from mm0 to mm7.</p>
<p>mm7 now contains “0x0000|0000|0000|cmcm” (| on inserted for readability).
Remember we duplicated the max and min values in the C-part.</p>
<p><code class="docutils literal notranslate"><span class="pre">pshufw</span> <span class="pre">mm7,mm7,0</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">pshufw</span> <span class="pre">mm6,mm6,0</span></code></p>
<p>These commands are
<a class="reference internal" href="IntegerSSE.html"><span class="doc">IntegerSSE</span></a> commands. They can shuffle around words in the mmx registers,
based on the last number.</p>
<p>In this example it results in mm7 containing “0xcmcm|cmcm|cmcm|cmcm”. So
basically cmax and cmin are now placed in all 8 bytes in the mm6 and mm7
registers.</p>
<p><code class="docutils literal notranslate"><span class="pre">yloop:</span></code></p>
<p>This is a jump destination for a jump routine.</p>
<p><code class="docutils literal notranslate"><span class="pre">mov</span> <span class="pre">edx,[row_size]</span></code></p>
<p>Every time we are looping on y, the rowsize is moved into edx.</p>
<p><code class="docutils literal notranslate"><span class="pre">align</span> <span class="pre">16</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">xloop:</span></code></p>
<p>The “align 16” is to be used before any loop destination, that will be
frequently used. It inserts commands that doesn’t do anything, and ensures
that the xloop destination will be aligned on a 16 byte boundary.</p>
<p><code class="docutils literal notranslate"><span class="pre">movq</span> <span class="pre">mm0,[ebx]</span></code></p>
<p>This command moves 8 bytes from the memory location in ebx into the mm0 register.</p>
<p>mm0 now contains 0xp8p7|p6p5|p4p3|p2p1, where p1 is the leftmost pixel
onscreen. This may look a bit backwards at first, but you’ll get used to it.</p>
<p><code class="docutils literal notranslate"><span class="pre">pminub</span> <span class="pre">mm0,mm7</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">pmaxub</span> <span class="pre">mm0,mm6</span></code></p>
<p>These commands compares each byte, and take the minimum and maximum and place it in mm0. (Remember -
result is always placed in the first register).</p>
<p><code class="docutils literal notranslate"><span class="pre">movq</span> <span class="pre">[ebx],mm0</span></code></p>
<p>This will put back the new values into the memory location that ebx points to.</p>
<p><code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">ebx,8</span></code></p>
<p>This command will add 8 to the pointer in ebx - making it
move on to the next 8 pixels. Remember: This is only the pointer we are
incrementing - we are not actually reading it, so even if this values gets
out of bounds nothing will happend here.</p>
<p><code class="docutils literal notranslate"><span class="pre">sub</span> <span class="pre">edx,8</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">jnz</span> <span class="pre">xloop</span></code></p>
<p>Here we subtract 8 from edx, and jump to the xloop location if the
values in edx isn’t 0 (jump if not zero).</p>
<p><code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">ebx,ecx;</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">dec</span> <span class="pre">eax</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">jnz</span> <span class="pre">yloop</span></code></p>
<p>This is the code that gets executed whenever the xloop
is finished. Here we add modulo to the ebx-pointer, decrements height and
jumps to the yloop as long as there are still pixels left to process.</p>
<p><code class="docutils literal notranslate"><span class="pre">emms</span></code></p>
<p>This instruction must be placed after all mmx code. It reenabled
float point code, which is disabled by mmx code.</p>
<hr class="docutils" />
<p>Back to <a class="reference internal" href="AssemblerOptimizing.html"><span class="doc">AssemblerOptimizing</span></a></p>
<p>$Date: 2014/10/27 22:04:54 $</p>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="SimpleSample.html" title="SimpleSample"
             >next</a> |</li>
        <li class="right" >
          <a href="SDKNecessaries.html" title="SDKNecessaries"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">AviSynth+ 3.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Invisible Tree</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2000-2019, AviSynth and AviSynth+ contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>